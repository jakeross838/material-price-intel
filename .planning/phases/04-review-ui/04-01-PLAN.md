---
phase: 04-review-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/migrations/007_extraction_trigger.sql
  - material-price-intel/supabase/migrations/008_approved_status_and_rpc.sql
  - material-price-intel/src/hooks/useUploadDocument.ts
autonomous: true

must_haves:
  truths:
    - "Uploading a PDF automatically triggers extraction via pg_net HTTP call from database trigger"
    - "Documents can have an 'approved' status after human review"
    - "approve_quote RPC marks quote as verified and document as approved in one call"
    - "RPCs only operate on data belonging to the caller's organization"
  artifacts:
    - path: "material-price-intel/supabase/migrations/007_extraction_trigger.sql"
      provides: "pg_net extension + trigger function + trigger on documents INSERT"
      contains: "net.http_post"
    - path: "material-price-intel/supabase/migrations/008_approved_status_and_rpc.sql"
      provides: "Approved status + approve_quote + update_quote_review RPCs with org ownership checks"
      contains: "user_org_id"
    - path: "material-price-intel/src/hooks/useUploadDocument.ts"
      provides: "Upload hook with client-side Edge Function invoke removed"
  key_links:
    - from: "documents INSERT trigger"
      to: "process-document Edge Function"
      via: "net.http_post with service role key"
      pattern: "net\\.http_post"
    - from: "approve_quote RPC"
      to: "quotes.is_verified + documents.status"
      via: "SQL function with org ownership check"
      pattern: "organization_id.*user_org_id"
    - from: "update_quote_review RPC"
      to: "quotes + line_items"
      via: "SQL function with org ownership check"
      pattern: "organization_id.*user_org_id"
---

<objective>
Fix the broken auto-extraction trigger and add database infrastructure for the review/approve workflow.

Purpose: The current client-side `supabase.functions.invoke()` call silently fails because Edge Functions require service role auth, not the anon key. Documents stay "pending" forever. This plan replaces the broken client-side trigger with a reliable pg_net database trigger. It also adds the `approved` document status and review RPCs (with organization ownership checks) needed by the review UI.

Output: Two SQL migrations (007 for extraction trigger, 008 for approve infrastructure), and an updated upload hook with the broken invoke removed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-extraction/03-03-SUMMARY.md

Key files:
@material-price-intel/src/hooks/useUploadDocument.ts
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/004_rls_policies.sql
@material-price-intel/supabase/migrations/006_job_queue.sql
@material-price-intel/supabase/functions/process-document/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pg_net database trigger for auto-extraction + remove broken client-side invoke</name>
  <files>
    material-price-intel/supabase/migrations/007_extraction_trigger.sql
    material-price-intel/src/hooks/useUploadDocument.ts
  </files>
  <action>
Create migration `007_extraction_trigger.sql` that enables pg_net and creates a database trigger to automatically call the `process-document` Edge Function when a document is inserted.

The migration must contain exactly this:

```sql
-- Enable pg_net extension for HTTP calls from PostgreSQL
CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;

-- Trigger function: calls process-document Edge Function via pg_net
-- Uses service role key for auth (SECURITY DEFINER = only visible to postgres role)
CREATE OR REPLACE FUNCTION public.trigger_document_extraction()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'pending' THEN
    PERFORM net.http_post(
      url := 'https://xgpjwpwhtfmbvoqtvete.supabase.co/functions/v1/process-document',
      headers := '{"Content-Type": "application/json", "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhncGp3cHdodGZtYnZvcXR2ZXRlIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc3MDY0Mjc2NywiZXhwIjoyMDg2MjE4NzY3fQ.iSxBuZ_sXiVB5frP8SOur3_U2_GSzHfTDTEQEStl8Fs"}'::jsonb,
      body := jsonb_build_object('document_id', NEW.id::text)
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Fire trigger on every INSERT to documents
CREATE TRIGGER on_document_insert_trigger_extraction
  AFTER INSERT ON documents
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_document_extraction();
```

Key details:
- The Edge Function URL is `https://xgpjwpwhtfmbvoqtvete.supabase.co/functions/v1/process-document`
- The service role key is hardcoded in the SECURITY DEFINER function (safe because only the postgres role can view function source)
- pg_net's `net.http_post` is async and non-blocking -- the INSERT completes immediately
- The function only fires when `status = 'pending'` to avoid re-triggering on status updates

Then update `useUploadDocument.ts`:
- Remove the entire fire-and-forget `supabase.functions.invoke('process-document', ...)` block and its surrounding `.then()/.catch()` chain
- The upload hook should end after the document INSERT succeeds -- extraction is now handled by the database trigger
- Keep all other logic (file upload to storage, document record creation, realtime subscription)
  </action>
  <verify>
    1. `007_extraction_trigger.sql` exists with `CREATE EXTENSION IF NOT EXISTS pg_net`, the trigger function using `net.http_post`, and the trigger on documents INSERT
    2. `useUploadDocument.ts` no longer contains `supabase.functions.invoke('process-document'`
    3. `npm run build` passes in `material-price-intel/`
  </verify>
  <done>
    The broken client-side Edge Function invoke is removed from useUploadDocument.ts. A pg_net database trigger on documents INSERT automatically calls the Edge Function with the service role key. Upload completes immediately and extraction fires asynchronously from the database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add approved status and review RPCs with organization ownership checks</name>
  <files>
    material-price-intel/supabase/migrations/008_approved_status_and_rpc.sql
    material-price-intel/src/lib/types.ts
  </files>
  <action>
Create migration `008_approved_status_and_rpc.sql` that adds the approved status and creates two RPCs with proper organization scoping.

1. **Add 'approved' to documents status CHECK constraint.** The existing inline CHECK constraint has an auto-generated name. Drop it dynamically:

```sql
-- Drop the existing status CHECK constraint (name may be auto-generated)
DO $$
DECLARE
  constraint_name TEXT;
BEGIN
  SELECT c.conname INTO constraint_name
  FROM pg_constraint c
  JOIN pg_attribute a ON a.attnum = ANY(c.conkey) AND a.attrelid = c.conrelid
  WHERE c.conrelid = 'public.documents'::regclass
    AND c.contype = 'c'
    AND a.attname = 'status';

  IF constraint_name IS NOT NULL THEN
    EXECUTE format('ALTER TABLE documents DROP CONSTRAINT %I', constraint_name);
  END IF;
END $$;

-- Re-add with 'approved' included
ALTER TABLE documents ADD CONSTRAINT documents_status_check
  CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'review_needed', 'approved'));
```

2. **Create `approve_quote` RPC** with organization ownership check:

```sql
CREATE OR REPLACE FUNCTION approve_quote(p_quote_id UUID)
RETURNS VOID AS $$
BEGIN
  -- Verify caller owns this quote's organization
  IF NOT EXISTS (
    SELECT 1 FROM quotes
    WHERE id = p_quote_id
      AND organization_id = public.user_org_id()
  ) THEN
    RAISE EXCEPTION 'Quote not found or access denied';
  END IF;

  -- Mark quote as verified
  UPDATE quotes
  SET is_verified = TRUE
  WHERE id = p_quote_id
    AND organization_id = public.user_org_id();

  -- Mark linked document as approved
  UPDATE documents
  SET status = 'approved',
      completed_at = COALESCE(completed_at, NOW())
  WHERE quote_id = p_quote_id
    AND organization_id = public.user_org_id();
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;
```

3. **Create `update_quote_review` RPC** with organization ownership check. Note: no `p_supplier_name` parameter (supplier editing is out of scope for review -- the checker flagged this as a dead parameter):

```sql
CREATE OR REPLACE FUNCTION update_quote_review(
  p_quote_id UUID,
  p_quote_number TEXT DEFAULT NULL,
  p_quote_date DATE DEFAULT NULL,
  p_project_name TEXT DEFAULT NULL,
  p_payment_terms TEXT DEFAULT NULL,
  p_valid_until DATE DEFAULT NULL,
  p_notes TEXT DEFAULT NULL,
  p_subtotal NUMERIC DEFAULT NULL,
  p_delivery_cost NUMERIC DEFAULT NULL,
  p_tax_amount NUMERIC DEFAULT NULL,
  p_tax_rate NUMERIC DEFAULT NULL,
  p_total_amount NUMERIC DEFAULT NULL,
  p_line_items JSONB DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
  item JSONB;
  i INT := 0;
BEGIN
  -- Verify caller owns this quote's organization
  IF NOT EXISTS (
    SELECT 1 FROM quotes
    WHERE id = p_quote_id
      AND organization_id = public.user_org_id()
  ) THEN
    RAISE EXCEPTION 'Quote not found or access denied';
  END IF;

  -- Update quote scalar fields (only non-null params)
  UPDATE quotes SET
    quote_number = COALESCE(p_quote_number, quote_number),
    quote_date = COALESCE(p_quote_date, quote_date),
    project_name = COALESCE(p_project_name, project_name),
    payment_terms = COALESCE(p_payment_terms, payment_terms),
    valid_until = COALESCE(p_valid_until, valid_until),
    notes = COALESCE(p_notes, notes),
    subtotal = COALESCE(p_subtotal, subtotal),
    delivery_cost = COALESCE(p_delivery_cost, delivery_cost),
    tax_amount = COALESCE(p_tax_amount, tax_amount),
    tax_rate = COALESCE(p_tax_rate, tax_rate),
    total_amount = COALESCE(p_total_amount, total_amount)
  WHERE id = p_quote_id
    AND organization_id = public.user_org_id();

  -- Replace line items if provided
  IF p_line_items IS NOT NULL THEN
    DELETE FROM line_items WHERE quote_id = p_quote_id;

    FOR item IN SELECT * FROM jsonb_array_elements(p_line_items)
    LOOP
      INSERT INTO line_items (
        quote_id, raw_description, quantity, unit, unit_price,
        extended_price, discount_pct, discount_amount, line_total,
        notes, sort_order, material_id
      ) VALUES (
        p_quote_id,
        item->>'raw_description',
        (item->>'quantity')::NUMERIC,
        item->>'unit',
        (item->>'unit_price')::NUMERIC,
        (item->>'extended_price')::NUMERIC,
        (item->>'discount_pct')::NUMERIC,
        (item->>'discount_amount')::NUMERIC,
        (item->>'line_total')::NUMERIC,
        item->>'notes',
        i,
        NULL
      );
      i := i + 1;
    END LOOP;
  END IF;
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;
```

4. **Update `src/lib/types.ts`** -- Add `'approved'` to the `DocumentStatus` union type:
```typescript
export type DocumentStatus =
  | "pending"
  | "processing"
  | "completed"
  | "failed"
  | "review_needed"
  | "approved";
```

**Design note for INGEST-03 compliance:** The extraction (Phase 3) already commits data to quotes/line_items tables with `is_verified = FALSE`. The review workflow operates post-facto on this provisional data. The `is_verified` flag distinguishes unreviewed (provisional) from reviewed (approved) data. This is by design -- re-extraction is expensive, and editing in-place is more practical.
  </action>
  <verify>
    1. `008_approved_status_and_rpc.sql` exists with dynamic constraint drop, approve_quote RPC, and update_quote_review RPC
    2. Both RPCs contain `organization_id = public.user_org_id()` ownership checks
    3. `update_quote_review` does NOT have a `p_supplier_name` parameter
    4. `types.ts` DocumentStatus includes 'approved'
    5. `npm run build` passes in `material-price-intel/`
  </verify>
  <done>
    The database supports 'approved' document status. approve_quote RPC atomically marks a quote as verified and its document as approved, with organization ownership validation. update_quote_review RPC allows saving edits to quote fields and replacing line items, also with ownership validation. No dead parameters. The TypeScript DocumentStatus type includes 'approved'.
  </done>
</task>

</tasks>

<verification>
1. Migration 007 enables pg_net and creates a trigger that calls the Edge Function via net.http_post
2. Migration 008 adds approved status, approve_quote RPC, update_quote_review RPC -- all with org ownership checks
3. useUploadDocument.ts no longer contains supabase.functions.invoke
4. types.ts DocumentStatus includes 'approved'
5. Both RPCs check `organization_id = public.user_org_id()` before any mutations
6. update_quote_review has no dead p_supplier_name parameter
7. `npm run build` passes cleanly
</verification>

<success_criteria>
- The broken client-side Edge Function invoke is removed and replaced with a pg_net database trigger
- Documents table supports 'approved' status via dynamic constraint replacement
- Two RPCs exist with organization ownership checks: approve_quote and update_quote_review
- TypeScript types updated to include approved status
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-review-ui/04-01-SUMMARY.md`
</output>
