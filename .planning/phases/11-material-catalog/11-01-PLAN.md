---
phase: 11-material-catalog
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/migrations/016_catalog_schema.sql
  - material-price-intel/src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "material_images table exists for storing material-level images separate from selection images"
    - "material_documents table exists for spec sheets and install guides linked to materials"
    - "room_category_mapping table maps room types to relevant material categories"
    - "Public RLS policies allow anonymous read access to catalog data"
    - "TypeScript types match the new database tables"
  artifacts:
    - path: "material-price-intel/supabase/migrations/016_catalog_schema.sql"
      provides: "Database tables for catalog: material_images, material_documents, room_category_mapping"
      contains: "CREATE TABLE material_images"
    - path: "material-price-intel/src/lib/types.ts"
      provides: "TypeScript types for new catalog tables"
      contains: "MaterialImage"
  key_links:
    - from: "material_images"
      to: "materials"
      via: "material_id FK"
      pattern: "REFERENCES materials\\(id\\)"
    - from: "material_documents"
      to: "materials"
      via: "material_id FK"
      pattern: "REFERENCES materials\\(id\\)"
    - from: "room_category_mapping"
      to: "material_categories"
      via: "category_id FK"
      pattern: "REFERENCES material_categories\\(id\\)"
---

<objective>
Create the database schema foundation for the material catalog. This adds three new tables: material_images (material-level product images), material_documents (spec sheets, install guides), and room_category_mapping (which categories belong in which room types). Also adds public RLS policies so the catalog can be consumed without authentication.

Purpose: Phase 11 is the visual foundation for the Dream Home Designer. The existing selection_images are per-project-selection; we need material-level images and documents that are reusable across all projects. The room-category mapping drives Phase 12's room-by-room selection flow.

Output: SQL migration file, updated TypeScript types, Database type helper extended.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/013_selection_images.sql
@material-price-intel/supabase/migrations/014_product_data_hub.sql
@material-price-intel/supabase/migrations/015_estimator_schema.sql
@material-price-intel/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 016_catalog_schema.sql</name>
  <files>material-price-intel/supabase/migrations/016_catalog_schema.sql</files>
  <action>
Create SQL migration with these tables:

**material_images** - Material-level product images (reusable across projects):
- id UUID PK DEFAULT gen_random_uuid()
- material_id UUID NOT NULL REFERENCES materials(id) ON DELETE CASCADE
- image_url TEXT NOT NULL (external URL or storage path)
- storage_path TEXT (if uploaded to Supabase Storage)
- thumbnail_url TEXT
- caption TEXT
- source TEXT (e.g., "manufacturer", "upload", "scraped")
- is_primary BOOLEAN DEFAULT FALSE
- sort_order INT DEFAULT 0
- metadata JSONB DEFAULT '{}'
- created_at TIMESTAMPTZ DEFAULT NOW()
- UNIQUE INDEX on (material_id) WHERE is_primary = TRUE (same pattern as selection_images)
- Indexes: material_id, is_primary

**material_documents** - Spec sheets, install guides linked to materials:
- id UUID PK DEFAULT gen_random_uuid()
- material_id UUID NOT NULL REFERENCES materials(id) ON DELETE CASCADE
- title TEXT NOT NULL
- doc_url TEXT NOT NULL (external URL)
- storage_path TEXT (if uploaded)
- doc_type TEXT NOT NULL DEFAULT 'spec_sheet' CHECK (doc_type IN ('spec_sheet', 'installation_guide', 'cut_sheet', 'warranty', 'care_guide', 'other'))
- file_size_bytes INT
- metadata JSONB DEFAULT '{}'
- created_at TIMESTAMPTZ DEFAULT NOW()
- Index: material_id, doc_type

**room_category_mapping** - Which categories apply to which room types:
- id UUID PK DEFAULT gen_random_uuid()
- room_type TEXT NOT NULL (e.g., 'kitchen', 'master_bath', 'great_room', 'bedroom', 'laundry', 'garage', 'exterior', 'office')
- category_id UUID NOT NULL REFERENCES material_categories(id) ON DELETE CASCADE
- sort_order INT DEFAULT 0 (controls display order of categories within a room)
- UNIQUE (room_type, category_id)
- Index: room_type

**RLS Policies:**
- material_images: Public SELECT (no auth required for catalog browsing). INSERT/UPDATE/DELETE requires org membership via materials.organization_id join chain + editor/admin role.
- material_documents: Same pattern as material_images.
- room_category_mapping: Public SELECT. INSERT/UPDATE/DELETE requires admin role (via user_profiles check, no org scoping needed since mappings are global).
- Add public SELECT policy on materials table (new policy alongside existing org-scoped one) — allow anonymous read for is_active=true materials only. Also add public SELECT on material_categories.

**Storage bucket:**
- Create 'material-catalog' bucket (public: true — catalog images should be publicly accessible)
- Storage policies: Org-scoped upload/delete (path: {org_id}/{material_id}/{filename}), public read

**Seed data for room_category_mapping** — insert sensible defaults:
- kitchen: cabinets, flooring, tile, fixtures, plumbing, appliances, paint
- master_bath: tile, plumbing, fixtures, cabinets, paint
- bathroom: tile, plumbing, fixtures, cabinets, paint
- great_room: flooring, fixtures, paint, windows
- bedroom: flooring, fixtures, paint, windows
- dining_room: flooring, fixtures, paint, windows
- office: flooring, fixtures, paint
- laundry: tile, plumbing, fixtures, cabinets, paint
- garage: flooring, paint
- exterior: roofing, windows, exterior, landscaping, paint

Use a CROSS JOIN with a subquery to look up category_id from material_categories.name for each mapping.

IMPORTANT: Do NOT use `organization_id` column on material_images or material_documents — they inherit org scope through the materials FK join, same pattern as material_aliases (see migration 009).
  </action>
  <verify>
    Review the SQL file for syntax correctness. Verify:
    - All three tables have proper constraints and indexes
    - RLS enabled on all three tables
    - Public SELECT policies exist for catalog read access
    - Org-scoped write policies use the join-chain pattern (material_id -> materials -> organization_id)
    - room_category_mapping seed data references material_categories by name
    - Storage bucket creation with public access
  </verify>
  <done>Migration file exists with all three tables, RLS policies, indexes, seed data, and storage bucket. SQL is syntactically valid.</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types and Database type entries</name>
  <files>material-price-intel/src/lib/types.ts</files>
  <action>
Add these type aliases to src/lib/types.ts (after the existing MaterialAlias type):

```typescript
export type MaterialImage = {
  id: string;
  material_id: string;
  image_url: string;
  storage_path: string | null;
  thumbnail_url: string | null;
  caption: string | null;
  source: string | null;
  is_primary: boolean;
  sort_order: number;
  metadata: Record<string, unknown>;
  created_at: string;
};

export type MaterialDocType = 'spec_sheet' | 'installation_guide' | 'cut_sheet' | 'warranty' | 'care_guide' | 'other';

export type MaterialDocument = {
  id: string;
  material_id: string;
  title: string;
  doc_url: string;
  storage_path: string | null;
  doc_type: MaterialDocType;
  file_size_bytes: number | null;
  metadata: Record<string, unknown>;
  created_at: string;
};

export type RoomType11 = 'kitchen' | 'master_bath' | 'bathroom' | 'great_room' | 'bedroom' | 'dining_room' | 'office' | 'laundry' | 'garage' | 'exterior';

export type RoomCategoryMapping = {
  id: string;
  room_type: string;
  category_id: string;
  sort_order: number;
};
```

Then add these entries to the Database.public.Tables object:

```typescript
material_images: {
  Row: MaterialImage;
  Insert: Pick<MaterialImage, 'material_id' | 'image_url'> & Partial<Omit<MaterialImage, 'id' | 'created_at' | 'material_id' | 'image_url'>>;
  Update: Partial<Omit<MaterialImage, 'id' | 'created_at'>>;
  Relationships: [
    {
      foreignKeyName: "material_images_material_id_fkey";
      columns: ["material_id"];
      isOneToOne: false;
      referencedRelation: "materials";
      referencedColumns: ["id"];
    },
  ];
};
material_documents: {
  Row: MaterialDocument;
  Insert: Pick<MaterialDocument, 'material_id' | 'title' | 'doc_url'> & Partial<Omit<MaterialDocument, 'id' | 'created_at' | 'material_id' | 'title' | 'doc_url'>>;
  Update: Partial<Omit<MaterialDocument, 'id' | 'created_at'>>;
  Relationships: [
    {
      foreignKeyName: "material_documents_material_id_fkey";
      columns: ["material_id"];
      isOneToOne: false;
      referencedRelation: "materials";
      referencedColumns: ["id"];
    },
  ];
};
room_category_mapping: {
  Row: RoomCategoryMapping;
  Insert: Pick<RoomCategoryMapping, 'room_type' | 'category_id'> & Partial<Omit<RoomCategoryMapping, 'id'>>;
  Update: Partial<Omit<RoomCategoryMapping, 'id'>>;
  Relationships: [
    {
      foreignKeyName: "room_category_mapping_category_id_fkey";
      columns: ["category_id"];
      isOneToOne: false;
      referencedRelation: "material_categories";
      referencedColumns: ["id"];
    },
  ];
};
```

Note: Use `type` alias, not `interface` — per project convention (Supabase generic constraint requires Record<string, unknown>).
  </action>
  <verify>Run `cd material-price-intel && npx tsc --noEmit` to check TypeScript compiles without errors.</verify>
  <done>TypeScript types for MaterialImage, MaterialDocument, RoomCategoryMapping exist in types.ts. Database type helper includes all three new tables with proper Insert/Update/Relationships. TypeScript compilation passes.</done>
</task>

</tasks>

<verification>
- [ ] 016_catalog_schema.sql exists with material_images, material_documents, room_category_mapping tables
- [ ] All tables have RLS enabled with public SELECT + org-scoped write
- [ ] room_category_mapping has seed data for 10 room types
- [ ] TypeScript types match SQL schema exactly
- [ ] Database type helper has all three new tables
- [ ] `npx tsc --noEmit` passes
</verification>

<success_criteria>
Three new database tables ready for catalog features. Public read access enabled for catalog browsing. TypeScript types compile. Room-category seed data loaded for the 10 standard room types. This schema supports both the admin catalog management UI (Plans 02-03) and the public catalog endpoint (Plan 04).
</success_criteria>

<output>
After completion, create `.planning/phases/11-material-catalog/11-01-SUMMARY.md`
</output>
