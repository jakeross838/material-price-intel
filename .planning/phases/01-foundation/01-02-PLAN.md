---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/config.toml
  - material-price-intel/supabase/migrations/001_extensions.sql
  - material-price-intel/supabase/migrations/002_schema.sql
  - material-price-intel/supabase/migrations/003_indexes.sql
  - material-price-intel/supabase/migrations/004_rls_policies.sql
  - material-price-intel/supabase/migrations/005_functions.sql
  - material-price-intel/supabase/seed.sql
  - material-price-intel/src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "All migration SQL files are syntactically valid PostgreSQL"
    - "Schema supports structured material fields: species, dimensions, grade, treatment, UOM"
    - "Material categories are extensible beyond lumber via material_categories table"
    - "Delivery cost and tax are separate quote-level columns, not in line items"
    - "RLS policies use organization-based isolation via auth.user_org_id() helper"
    - "TypeScript types mirror the database schema exactly"
    - "pg_trgm extension is enabled and GIN indexes are created on material name fields"
  artifacts:
    - path: "material-price-intel/supabase/migrations/001_extensions.sql"
      provides: "PostgreSQL extensions (pg_trgm)"
      contains: "pg_trgm"
    - path: "material-price-intel/supabase/migrations/002_schema.sql"
      provides: "All table definitions"
      contains: "CREATE TABLE"
      min_lines: 80
    - path: "material-price-intel/supabase/migrations/003_indexes.sql"
      provides: "Performance indexes including GIN trigram indexes"
      contains: "gin_trgm_ops"
    - path: "material-price-intel/supabase/migrations/004_rls_policies.sql"
      provides: "Row Level Security policies for all tables"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "material-price-intel/supabase/migrations/005_functions.sql"
      provides: "Database helper functions including find_similar_material"
      contains: "find_similar_material"
    - path: "material-price-intel/supabase/seed.sql"
      provides: "Seed data for material categories"
      contains: "material_categories"
    - path: "material-price-intel/src/lib/types.ts"
      provides: "TypeScript type definitions for all database tables"
      contains: "Supplier"
  key_links:
    - from: "material-price-intel/supabase/migrations/004_rls_policies.sql"
      to: "material-price-intel/supabase/migrations/002_schema.sql"
      via: "RLS policies reference tables created in 002"
      pattern: "ALTER TABLE.*ENABLE ROW LEVEL SECURITY"
    - from: "material-price-intel/supabase/migrations/003_indexes.sql"
      to: "material-price-intel/supabase/migrations/001_extensions.sql"
      via: "GIN indexes require pg_trgm extension from 001"
      pattern: "gin_trgm_ops"
    - from: "material-price-intel/src/lib/types.ts"
      to: "material-price-intel/supabase/migrations/002_schema.sql"
      via: "TypeScript types mirror SQL table definitions"
      pattern: "interface.*Supplier|Quote|Material|LineItem"
---

<objective>
Write all database migration SQL files, seed data, and TypeScript type definitions for the complete Phase 1 schema. This includes organizations, user profiles, suppliers, materials, material categories, documents, quotes, line items, and all supporting indexes, RLS policies, and database functions.

Purpose: Define the complete data model that every feature in the system depends on. The schema is designed from the architecture research and supports structured material fields, organization-based multi-tenancy, fuzzy text search, and separate delivery/tax tracking.
Output: Migration SQL files ready to apply to Supabase, seed data for material categories, and TypeScript types for the frontend.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md (database schema section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase project and write migration SQL files</name>
  <files>
    material-price-intel/supabase/config.toml
    material-price-intel/supabase/migrations/001_extensions.sql
    material-price-intel/supabase/migrations/002_schema.sql
    material-price-intel/supabase/migrations/003_indexes.sql
    material-price-intel/supabase/migrations/004_rls_policies.sql
    material-price-intel/supabase/migrations/005_functions.sql
    material-price-intel/supabase/seed.sql
  </files>
  <action>
    1. Initialize the Supabase directory structure. From the `material-price-intel/` directory, run:
       ```
       npx supabase init
       ```
       This creates `supabase/config.toml` and the `supabase/migrations/` directory.
       If `supabase` CLI is not available globally, use `npx supabase`.

    2. Create `supabase/migrations/001_extensions.sql`:
       ```sql
       -- Enable required PostgreSQL extensions
       CREATE EXTENSION IF NOT EXISTS pg_trgm;  -- Fuzzy text matching (trigram similarity)
       ```
       NOTE: Do NOT include pg_cron or pg_net -- those require Supabase dashboard enabling and are not needed until Phase 2.

    3. Create `supabase/migrations/002_schema.sql` with ALL tables from the architecture research. Use the EXACT schema from ARCHITECTURE.md with these v1 scope adjustments:
       - Include: organizations, user_profiles, suppliers, material_categories, materials, documents, quotes, line_items
       - EXCLUDE: price_alerts (v2 feature), query_log (v2 feature)
       - Add `updated_at` trigger function for auto-updating timestamps.

       Tables to create (in order for FK dependencies):
       a. `organizations` -- id, name, created_at
       b. `user_profiles` -- id (references auth.users), organization_id, display_name, role (admin/editor/viewer), created_at
       c. `suppliers` -- id, organization_id, name, normalized_name, contact_name, contact_email, contact_phone, address, notes, created_at, updated_at. UNIQUE on (organization_id, normalized_name).
       d. `material_categories` -- id, name (unique), display_name, sort_order
       e. `materials` -- id, organization_id, category_id, canonical_name, species, dimensions, grade, treatment, unit_of_measure (default 'piece'), description, aliases (TEXT[] default '{}'), is_active (default true), created_at, updated_at. UNIQUE on (organization_id, canonical_name).
       f. `documents` -- id, organization_id, file_path, file_type (pdf/xlsx/csv/email_text), file_name, file_size_bytes, source (upload/email), email_from, email_subject, email_body, content_text, status (pending/processing/completed/failed/review_needed), error_message, quote_id, uploaded_by (references auth.users), started_at, completed_at, created_at.
       g. `quotes` -- id, organization_id, document_id, supplier_id, quote_number, quote_date, valid_until, project_name, subtotal NUMERIC(12,2), delivery_cost NUMERIC(12,2), tax_amount NUMERIC(12,2), tax_rate NUMERIC(5,4) DEFAULT 0.07, total_amount NUMERIC(12,2), payment_terms, notes, confidence_score NUMERIC(3,2), raw_extraction JSONB, is_verified (default false), created_at, updated_at.
       h. `line_items` -- id, quote_id (ON DELETE CASCADE), material_id (nullable), raw_description, quantity NUMERIC(12,4), unit, unit_price NUMERIC(12,4), extended_price NUMERIC(12,2), discount_pct NUMERIC(5,2), discount_amount NUMERIC(12,2), line_total NUMERIC(12,2), notes, sort_order (default 0), created_at.

       Also create the auto-update trigger function and apply it to all tables with `updated_at`:
       ```sql
       CREATE OR REPLACE FUNCTION update_updated_at_column()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = NOW();
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql;

       CREATE TRIGGER update_suppliers_updated_at BEFORE UPDATE ON suppliers
         FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
       CREATE TRIGGER update_materials_updated_at BEFORE UPDATE ON materials
         FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
       CREATE TRIGGER update_quotes_updated_at BEFORE UPDATE ON quotes
         FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
       ```

    4. Create `supabase/migrations/003_indexes.sql` with all indexes from the architecture research:
       ```sql
       -- Job queue: find pending documents fast
       CREATE INDEX idx_documents_status_created ON documents(status, created_at) WHERE status IN ('pending', 'processing');
       -- Material lookup: trigram similarity search
       CREATE INDEX idx_materials_canonical_name_trgm ON materials USING gin (canonical_name gin_trgm_ops);
       CREATE INDEX idx_materials_species_trgm ON materials USING gin (species gin_trgm_ops);
       CREATE INDEX idx_materials_dimensions ON materials(dimensions);
       -- Price queries: material + date lookups
       CREATE INDEX idx_line_items_material_id ON line_items(material_id);
       CREATE INDEX idx_quotes_supplier_date ON quotes(supplier_id, quote_date DESC);
       CREATE INDEX idx_quotes_organization_date ON quotes(organization_id, quote_date DESC);
       CREATE INDEX idx_quotes_project_name ON quotes(project_name);
       -- Supplier dedup
       CREATE INDEX idx_suppliers_normalized_name_trgm ON suppliers USING gin (normalized_name gin_trgm_ops);
       -- Document lookup by quote
       CREATE INDEX idx_documents_quote_id ON documents(quote_id) WHERE quote_id IS NOT NULL;
       -- Line items by quote (for loading all line items in a quote)
       CREATE INDEX idx_line_items_quote_id ON line_items(quote_id);
       ```

    5. Create `supabase/migrations/004_rls_policies.sql`:
       - First, create the `auth.user_org_id()` helper function.
       - Enable RLS on ALL tables: organizations, user_profiles, suppliers, material_categories, materials, documents, quotes, line_items.
       - For organization-scoped tables (suppliers, materials, documents, quotes): Users see rows where organization_id = auth.user_org_id(). Editors/admins can insert/update. Admins can delete.
       - For `line_items`: Use a join to quotes to check organization access (line_items don't have organization_id directly). Create a policy that checks the parent quote's organization_id.
       - For `material_categories`: SELECT for all authenticated users (these are global). INSERT/UPDATE/DELETE only for admin role.
       - For `user_profiles`: Users can see own org profiles. Users can update their own profile. Admins can manage all profiles in their org.
       - For `organizations`: Users can see their own org.

       Use this pattern consistently:
       ```sql
       -- SELECT: organization member can read
       CREATE POLICY "org_select" ON {table} FOR SELECT
         USING (organization_id = auth.user_org_id());
       -- INSERT: editor or admin can create
       CREATE POLICY "org_insert" ON {table} FOR INSERT
         WITH CHECK (organization_id = auth.user_org_id()
           AND EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role IN ('admin', 'editor')));
       -- UPDATE: editor or admin can modify
       CREATE POLICY "org_update" ON {table} FOR UPDATE
         USING (organization_id = auth.user_org_id()
           AND EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role IN ('admin', 'editor')));
       -- DELETE: admin only
       CREATE POLICY "org_delete" ON {table} FOR DELETE
         USING (organization_id = auth.user_org_id()
           AND EXISTS (SELECT 1 FROM user_profiles WHERE id = auth.uid() AND role = 'admin'));
       ```

    6. Create `supabase/migrations/005_functions.sql`:
       - `find_similar_material(p_org_id UUID, p_search_name TEXT, p_threshold REAL DEFAULT 0.3)`:
         Returns TABLE(id UUID, canonical_name TEXT, similarity REAL). Uses pg_trgm similarity operator. Limits to top 5 results.
       - `get_material_price_history(p_material_id UUID, p_org_id UUID)`:
         Returns recent prices for a material across all suppliers. Joins line_items -> quotes -> suppliers. Orders by quote_date DESC. Limits to 50.

    7. Create `supabase/seed.sql` with initial material categories:
       ```sql
       INSERT INTO material_categories (name, display_name, sort_order) VALUES
         ('lumber', 'Lumber & Framing', 1),
         ('windows', 'Windows & Doors', 2),
         ('cabinets', 'Cabinets & Countertops', 3),
         ('flooring', 'Flooring', 4),
         ('roofing', 'Roofing', 5),
         ('hardware', 'Hardware & Fasteners', 6),
         ('other', 'Other Materials', 99)
       ON CONFLICT (name) DO NOTHING;
       ```

    IMPORTANT: Use `TIMESTAMPTZ` (not TIMESTAMP) for all date/time columns. Use `gen_random_uuid()` for UUID defaults (built into PostgreSQL 13+, no extension needed).
  </action>
  <verify>
    Review each SQL file for syntax correctness:
    1. All CREATE TABLE statements have matching parentheses and valid column types
    2. Foreign key references point to tables that exist (created in correct order)
    3. RLS policies reference the correct tables and use valid SQL
    4. Indexes reference columns that exist on the correct tables
    5. Functions have correct parameter types and return types
    6. No references to pg_cron or pg_net (not needed yet)

    If Supabase CLI is available locally with Docker, run `npx supabase db reset` to validate migrations. If not, this is validated in Plan 03 when connecting to the actual Supabase project.
  </verify>
  <done>
    - 5 migration SQL files created in supabase/migrations/
    - seed.sql created with 7 material categories
    - All tables from the architecture research are defined (minus v2 tables)
    - pg_trgm extension enabled in 001
    - GIN trigram indexes created in 003
    - RLS enabled on ALL tables with organization-based policies in 004
    - Helper functions created in 005
    - updated_at triggers on suppliers, materials, quotes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript type definitions mirroring the database schema</name>
  <files>
    material-price-intel/src/lib/types.ts
  </files>
  <action>
    Create `src/lib/types.ts` with TypeScript interfaces for every database table. These types will be used throughout the React frontend for type-safe data access.

    Define the following interfaces:

    ```typescript
    // Database row types -- mirror the SQL schema exactly

    export interface Organization {
      id: string;
      name: string;
      created_at: string;
    }

    export interface UserProfile {
      id: string;
      organization_id: string;
      display_name: string;
      role: "admin" | "editor" | "viewer";
      created_at: string;
    }

    export interface Supplier {
      id: string;
      organization_id: string;
      name: string;
      normalized_name: string;
      contact_name: string | null;
      contact_email: string | null;
      contact_phone: string | null;
      address: string | null;
      notes: string | null;
      created_at: string;
      updated_at: string;
    }

    export interface MaterialCategory {
      id: string;
      name: string;
      display_name: string;
      sort_order: number;
    }

    export interface Material {
      id: string;
      organization_id: string;
      category_id: string;
      canonical_name: string;
      species: string | null;
      dimensions: string | null;
      grade: string | null;
      treatment: string | null;
      unit_of_measure: string;
      description: string | null;
      aliases: string[];
      is_active: boolean;
      created_at: string;
      updated_at: string;
    }

    export type DocumentFileType = "pdf" | "xlsx" | "csv" | "email_text";
    export type DocumentSource = "upload" | "email";
    export type DocumentStatus = "pending" | "processing" | "completed" | "failed" | "review_needed";

    export interface Document {
      id: string;
      organization_id: string;
      file_path: string | null;
      file_type: DocumentFileType;
      file_name: string | null;
      file_size_bytes: number | null;
      source: DocumentSource;
      email_from: string | null;
      email_subject: string | null;
      email_body: string | null;
      content_text: string | null;
      status: DocumentStatus;
      error_message: string | null;
      quote_id: string | null;
      uploaded_by: string | null;
      started_at: string | null;
      completed_at: string | null;
      created_at: string;
    }

    export interface Quote {
      id: string;
      organization_id: string;
      document_id: string | null;
      supplier_id: string;
      quote_number: string | null;
      quote_date: string | null;
      valid_until: string | null;
      project_name: string | null;
      subtotal: number | null;
      delivery_cost: number | null;
      tax_amount: number | null;
      tax_rate: number | null;
      total_amount: number | null;
      payment_terms: string | null;
      notes: string | null;
      confidence_score: number | null;
      raw_extraction: Record<string, unknown> | null;
      is_verified: boolean;
      created_at: string;
      updated_at: string;
    }

    export interface LineItem {
      id: string;
      quote_id: string;
      material_id: string | null;
      raw_description: string;
      quantity: number | null;
      unit: string | null;
      unit_price: number | null;
      extended_price: number | null;
      discount_pct: number | null;
      discount_amount: number | null;
      line_total: number | null;
      notes: string | null;
      sort_order: number;
      created_at: string;
    }

    // Supabase Database type helper for use with supabase-js typed client
    export interface Database {
      public: {
        Tables: {
          organizations: { Row: Organization; Insert: Omit<Organization, "id" | "created_at">; Update: Partial<Omit<Organization, "id">> };
          user_profiles: { Row: UserProfile; Insert: Omit<UserProfile, "created_at">; Update: Partial<Omit<UserProfile, "id">> };
          suppliers: { Row: Supplier; Insert: Omit<Supplier, "id" | "created_at" | "updated_at">; Update: Partial<Omit<Supplier, "id" | "created_at">> };
          material_categories: { Row: MaterialCategory; Insert: Omit<MaterialCategory, "id">; Update: Partial<Omit<MaterialCategory, "id">> };
          materials: { Row: Material; Insert: Omit<Material, "id" | "created_at" | "updated_at">; Update: Partial<Omit<Material, "id" | "created_at">> };
          documents: { Row: Document; Insert: Omit<Document, "id" | "created_at">; Update: Partial<Omit<Document, "id" | "created_at">> };
          quotes: { Row: Quote; Insert: Omit<Quote, "id" | "created_at" | "updated_at">; Update: Partial<Omit<Quote, "id" | "created_at">> };
          line_items: { Row: LineItem; Insert: Omit<LineItem, "id" | "created_at">; Update: Partial<Omit<LineItem, "id" | "created_at">> };
        };
      };
    }
    ```

    Use string for all UUID fields (Supabase returns UUIDs as strings).
    Use string for all TIMESTAMPTZ fields (Supabase returns ISO8601 strings).
    Use number for all NUMERIC fields (Supabase returns numbers from numeric columns via the JS client).
    Use `string | null` for nullable columns.
    Use `Record<string, unknown>` for JSONB columns.

    NOTE: The `Database` type at the bottom enables typed Supabase client usage:
    ```typescript
    const supabase = createClient<Database>(url, key);
    // Now supabase.from('quotes').select() returns typed Quote rows
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` from the `material-price-intel/` directory (or `npm run build` which includes type checking). Verify zero TypeScript errors in `src/lib/types.ts`.
  </verify>
  <done>
    - `src/lib/types.ts` defines interfaces for all 8 tables
    - All nullable fields use `T | null`
    - Enums for DocumentFileType, DocumentSource, DocumentStatus
    - Database helper type enables typed Supabase client
    - Zero TypeScript compilation errors
  </done>
</task>

</tasks>

<verification>
1. All 5 migration files exist in `supabase/migrations/` with valid SQL syntax
2. `seed.sql` exists with material category inserts
3. `src/lib/types.ts` compiles without TypeScript errors
4. Schema matches the architecture research: organizations, user_profiles, suppliers, material_categories, materials, documents, quotes, line_items
5. Material table has: species, dimensions, grade, treatment, unit_of_measure, aliases (TEXT[])
6. Quotes table has: delivery_cost and tax_amount as separate NUMERIC columns
7. pg_trgm GIN indexes exist on materials.canonical_name, materials.species, suppliers.normalized_name
8. RLS policies exist for ALL tables using auth.user_org_id() pattern
</verification>

<success_criteria>
- Complete database schema defined in SQL migration files
- All tables have proper foreign keys and constraints
- pg_trgm extension enabled for fuzzy text matching
- GIN indexes created on material name fields for fast search
- RLS policies enforce organization-based row isolation on every table
- TypeScript types match database schema 1:1
- Seed data provides starting material categories (lumber, windows, cabinets, flooring, roofing, hardware, other)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
