---
phase: 10-estimating-procurement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/migrations/012_estimating_schema.sql
  - material-price-intel/src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "Projects table exists with name, address, sqft, client info, target budget"
    - "Rooms/areas can be assigned to projects with material category scoping"
    - "Selections link rooms to materials with allowance amounts, quantities, and pricing"
    - "Procurement records track buyout status from not_quoted through installed"
    - "RLS enforces organization scoping on all new tables"
    - "TypeScript types match SQL schema exactly"
  artifacts:
    - path: "material-price-intel/supabase/migrations/012_estimating_schema.sql"
      provides: "All estimating/procurement tables, RLS policies, indexes, RPC functions"
      contains: "CREATE TABLE projects"
    - path: "material-price-intel/src/lib/types.ts"
      provides: "TypeScript types for all new tables"
      contains: "Project"
  key_links:
    - from: "projects"
      to: "organizations"
      via: "organization_id FK"
      pattern: "REFERENCES organizations"
    - from: "project_rooms"
      to: "projects"
      via: "project_id FK"
      pattern: "REFERENCES projects"
    - from: "project_selections"
      to: "project_rooms"
      via: "room_id FK"
      pattern: "REFERENCES project_rooms"
    - from: "project_selections"
      to: "materials"
      via: "material_id FK"
      pattern: "REFERENCES materials"
    - from: "procurement_items"
      to: "project_selections"
      via: "selection_id FK"
      pattern: "REFERENCES project_selections"
---

<objective>
Create the database schema and TypeScript types for project estimating and procurement tracking.

Purpose: This is the foundation for all Phase 10 features. Every subsequent plan depends on these tables existing with proper RLS and the TypeScript types being available.

Output: One migration file with all tables, indexes, RLS policies, and helper RPCs. Updated types.ts with all new type definitions and Database helper updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/004_rls_policies.sql
@material-price-intel/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 012_estimating_schema.sql</name>
  <files>material-price-intel/supabase/migrations/012_estimating_schema.sql</files>
  <action>
Create a single migration file that establishes the complete estimating and procurement data model. Follow the exact patterns from 002_schema.sql and 004_rls_policies.sql.

**Tables to create:**

1. **projects** - The custom home being built
   - id UUID PK DEFAULT gen_random_uuid()
   - organization_id UUID NOT NULL REFERENCES organizations(id)
   - name TEXT NOT NULL (e.g., "Smith Residence")
   - address TEXT (full street address in Bradenton, FL area)
   - city TEXT DEFAULT 'Bradenton'
   - state TEXT DEFAULT 'FL'
   - square_footage NUMERIC(10,2) (total heated sqft)
   - client_name TEXT (homeowner name)
   - client_email TEXT
   - client_phone TEXT
   - target_budget NUMERIC(14,2) (total material budget for the home)
   - status TEXT NOT NULL DEFAULT 'planning' CHECK (status IN ('planning', 'estimating', 'in_progress', 'completed', 'on_hold'))
   - notes TEXT
   - start_date DATE
   - estimated_completion DATE
   - created_at TIMESTAMPTZ DEFAULT NOW()
   - updated_at TIMESTAMPTZ DEFAULT NOW()
   - UNIQUE (organization_id, name)
   - Add update_updated_at trigger

2. **project_rooms** - Rooms/areas within a home
   - id UUID PK DEFAULT gen_random_uuid()
   - project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE
   - name TEXT NOT NULL (e.g., "Master Bath", "Kitchen", "Great Room", "Guest Bath 1", "Exterior")
   - room_type TEXT NOT NULL DEFAULT 'interior' CHECK (room_type IN ('interior', 'exterior', 'utility', 'common'))
   - sort_order INT DEFAULT 0
   - notes TEXT
   - created_at TIMESTAMPTZ DEFAULT NOW()
   - UNIQUE (project_id, name)

3. **project_selections** - Material selections within a room
   - id UUID PK DEFAULT gen_random_uuid()
   - room_id UUID NOT NULL REFERENCES project_rooms(id) ON DELETE CASCADE
   - category_id UUID REFERENCES material_categories(id) (e.g., Flooring, Countertops, Cabinets)
   - material_id UUID REFERENCES materials(id) (the selected canonical material, null if not yet selected)
   - selection_name TEXT NOT NULL (human label: "Kitchen Flooring", "Master Bath Countertop")
   - description TEXT (details: "Red Oak Hardwood, 3/4 inch, select grade")
   - allowance_amount NUMERIC(12,2) (budget allowance included in base price)
   - quantity NUMERIC(12,4) (e.g., 800 sqft)
   - unit TEXT DEFAULT 'sqft' (e.g., 'sqft', 'lf', 'ea', 'pc')
   - estimated_unit_price NUMERIC(12,4) (from historical pricing)
   - estimated_total NUMERIC(12,2) (quantity * estimated_unit_price, or manual override)
   - actual_unit_price NUMERIC(12,4) (from awarded quote)
   - actual_total NUMERIC(12,2) (from awarded quote/PO)
   - variance_amount NUMERIC(12,2) GENERATED ALWAYS AS (COALESCE(actual_total, estimated_total, 0) - COALESCE(allowance_amount, 0)) STORED
   - upgrade_status TEXT DEFAULT 'pending' CHECK (upgrade_status IN ('pending', 'standard', 'upgrade', 'downgrade'))
   - supplier_id UUID REFERENCES suppliers(id) (preferred/awarded supplier)
   - sort_order INT DEFAULT 0
   - notes TEXT
   - created_at TIMESTAMPTZ DEFAULT NOW()
   - updated_at TIMESTAMPTZ DEFAULT NOW()
   - Add update_updated_at trigger

4. **procurement_items** - Buyout tracking for selections
   - id UUID PK DEFAULT gen_random_uuid()
   - selection_id UUID NOT NULL REFERENCES project_selections(id) ON DELETE CASCADE
   - quote_id UUID REFERENCES quotes(id) (linked supplier quote)
   - line_item_id UUID REFERENCES line_items(id) (specific line item from quote)
   - status TEXT NOT NULL DEFAULT 'not_quoted' CHECK (status IN ('not_quoted', 'rfq_sent', 'quoted', 'awarded', 'ordered', 'delivered', 'installed'))
   - po_number TEXT (purchase order number once ordered)
   - ordered_date DATE
   - expected_delivery DATE
   - actual_delivery DATE
   - committed_price NUMERIC(12,2) (locked-in price from awarded quote)
   - notes TEXT
   - created_at TIMESTAMPTZ DEFAULT NOW()
   - updated_at TIMESTAMPTZ DEFAULT NOW()
   - Add update_updated_at trigger
   - UNIQUE (selection_id) -- one procurement record per selection

**RLS Policies:**

For projects: Standard org-scoped CRUD (same pattern as suppliers table in 004_rls_policies.sql).

For project_rooms: Access via parent project's organization_id. Use subquery pattern:
```sql
EXISTS (SELECT 1 FROM projects WHERE projects.id = project_rooms.project_id AND projects.organization_id = public.user_org_id())
```

For project_selections: Access via project_rooms -> projects chain:
```sql
EXISTS (
  SELECT 1 FROM project_rooms
  JOIN projects ON projects.id = project_rooms.project_id
  WHERE project_rooms.id = project_selections.room_id
    AND projects.organization_id = public.user_org_id()
)
```

For procurement_items: Access via selection -> room -> project chain:
```sql
EXISTS (
  SELECT 1 FROM project_selections
  JOIN project_rooms ON project_rooms.id = project_selections.room_id
  JOIN projects ON projects.id = project_rooms.project_id
  WHERE project_selections.id = procurement_items.selection_id
    AND projects.organization_id = public.user_org_id()
)
```

For all tables: SELECT for any authenticated org member, INSERT/UPDATE for admin+editor, DELETE for admin only.

**Indexes:**
- idx_projects_org ON projects(organization_id)
- idx_projects_status ON projects(status)
- idx_project_rooms_project ON project_rooms(project_id)
- idx_project_selections_room ON project_selections(room_id)
- idx_project_selections_material ON project_selections(material_id)
- idx_project_selections_category ON project_selections(category_id)
- idx_procurement_items_selection ON procurement_items(selection_id)
- idx_procurement_items_quote ON procurement_items(quote_id)
- idx_procurement_items_status ON procurement_items(status)

**RPC Functions:**

1. `get_project_summary(p_project_id UUID)` - Returns project with aggregated totals:
   - total_allowance (SUM of allowance_amount across all selections)
   - total_estimated (SUM of estimated_total)
   - total_actual (SUM of actual_total for items with actual prices)
   - total_variance (SUM of variance_amount)
   - selection_count (COUNT of selections)
   - items_bought_out (COUNT of procurement_items with status IN ('awarded','ordered','delivered','installed'))
   Must verify caller's org owns the project.

2. `get_material_price_stats(p_material_id UUID)` - Returns pricing statistics for estimate generation:
   - avg_price (average effective_unit_price from approved quotes)
   - min_price
   - max_price
   - quote_count (number of approved quotes with this material)
   - latest_price (most recent quote's effective_unit_price)
   - latest_supplier (supplier name from most recent quote)
   Query should filter to line_type='material', is_verified=true quotes only.
   Must verify caller's org owns the material.

**IMPORTANT NOTES:**
- Use TIMESTAMPTZ for all timestamps (project convention)
- Use gen_random_uuid() for all UUIDs (project convention)
- The variance_amount is a GENERATED column -- Supabase/PostgreSQL will auto-compute it
- Follow the exact same RLS pattern structure as 004_rls_policies.sql
- Enable RLS on all new tables
  </action>
  <verify>
Review the SQL file for:
1. All 4 tables created with correct columns and constraints
2. All CHECK constraints on status/type columns
3. All FK relationships correct
4. RLS enabled on all tables with proper policies
5. All indexes created
6. Both RPC functions defined
7. Generated column syntax correct for variance_amount
8. update_updated_at triggers on projects, project_selections, procurement_items
  </verify>
  <done>Migration file exists with all tables, RLS, indexes, triggers, and RPCs. SQL is syntactically valid.</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types for estimating tables</name>
  <files>material-price-intel/src/lib/types.ts</files>
  <action>
Add new type definitions to the existing types.ts file. Place them after the existing MaterialAlias type and before the Database helper type. Follow the exact same pattern as existing types (use `type` not `interface`, match SQL column names exactly).

**New types to add:**

```typescript
export type ProjectStatus = 'planning' | 'estimating' | 'in_progress' | 'completed' | 'on_hold';

export type Project = {
  id: string;
  organization_id: string;
  name: string;
  address: string | null;
  city: string | null;
  state: string | null;
  square_footage: number | null;
  client_name: string | null;
  client_email: string | null;
  client_phone: string | null;
  target_budget: number | null;
  status: ProjectStatus;
  notes: string | null;
  start_date: string | null;
  estimated_completion: string | null;
  created_at: string;
  updated_at: string;
};

export type RoomType = 'interior' | 'exterior' | 'utility' | 'common';

export type ProjectRoom = {
  id: string;
  project_id: string;
  name: string;
  room_type: RoomType;
  sort_order: number;
  notes: string | null;
  created_at: string;
};

export type UpgradeStatus = 'pending' | 'standard' | 'upgrade' | 'downgrade';

export type ProjectSelection = {
  id: string;
  room_id: string;
  category_id: string | null;
  material_id: string | null;
  selection_name: string;
  description: string | null;
  allowance_amount: number | null;
  quantity: number | null;
  unit: string | null;
  estimated_unit_price: number | null;
  estimated_total: number | null;
  actual_unit_price: number | null;
  actual_total: number | null;
  variance_amount: number | null;
  upgrade_status: UpgradeStatus;
  supplier_id: string | null;
  sort_order: number;
  notes: string | null;
  created_at: string;
  updated_at: string;
};

export type ProcurementStatus = 'not_quoted' | 'rfq_sent' | 'quoted' | 'awarded' | 'ordered' | 'delivered' | 'installed';

export type ProcurementItem = {
  id: string;
  selection_id: string;
  quote_id: string | null;
  line_item_id: string | null;
  status: ProcurementStatus;
  po_number: string | null;
  ordered_date: string | null;
  expected_delivery: string | null;
  actual_delivery: string | null;
  committed_price: number | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
};

export type ProjectSummary = {
  total_allowance: number;
  total_estimated: number;
  total_actual: number;
  total_variance: number;
  selection_count: number;
  items_bought_out: number;
};

export type MaterialPriceStats = {
  avg_price: number | null;
  min_price: number | null;
  max_price: number | null;
  quote_count: number;
  latest_price: number | null;
  latest_supplier: string | null;
};
```

**Update the Database type** to include the new tables in Tables and the new RPCs in Functions:

Add to Tables (follow existing pattern for Row/Insert/Update/Relationships):

- projects: Row=Project, Insert omits id/created_at/updated_at, Update partial omits id/created_at
- project_rooms: Row=ProjectRoom, Insert omits id/created_at, Update partial omits id/created_at
- project_selections: Row=ProjectSelection, Insert omits id/created_at/updated_at/variance_amount (generated column), Update partial omits id/created_at/variance_amount
- procurement_items: Row=ProcurementItem, Insert omits id/created_at/updated_at, Update partial omits id/created_at

Relationships for project_rooms:
```typescript
Relationships: [
  {
    foreignKeyName: "project_rooms_project_id_fkey";
    columns: ["project_id"];
    isOneToOne: false;
    referencedRelation: "projects";
    referencedColumns: ["id"];
  },
];
```

Relationships for project_selections:
```typescript
Relationships: [
  {
    foreignKeyName: "project_selections_room_id_fkey";
    columns: ["room_id"];
    isOneToOne: false;
    referencedRelation: "project_rooms";
    referencedColumns: ["id"];
  },
  {
    foreignKeyName: "project_selections_material_id_fkey";
    columns: ["material_id"];
    isOneToOne: false;
    referencedRelation: "materials";
    referencedColumns: ["id"];
  },
  {
    foreignKeyName: "project_selections_category_id_fkey";
    columns: ["category_id"];
    isOneToOne: false;
    referencedRelation: "material_categories";
    referencedColumns: ["id"];
  },
  {
    foreignKeyName: "project_selections_supplier_id_fkey";
    columns: ["supplier_id"];
    isOneToOne: false;
    referencedRelation: "suppliers";
    referencedColumns: ["id"];
  },
];
```

Relationships for procurement_items:
```typescript
Relationships: [
  {
    foreignKeyName: "procurement_items_selection_id_fkey";
    columns: ["selection_id"];
    isOneToOne: true;
    referencedRelation: "project_selections";
    referencedColumns: ["id"];
  },
  {
    foreignKeyName: "procurement_items_quote_id_fkey";
    columns: ["quote_id"];
    isOneToOne: false;
    referencedRelation: "quotes";
    referencedColumns: ["id"];
  },
  {
    foreignKeyName: "procurement_items_line_item_id_fkey";
    columns: ["line_item_id"];
    isOneToOne: false;
    referencedRelation: "line_items";
    referencedColumns: ["id"];
  },
];
```

Add to Functions:
```typescript
get_project_summary: {
  Args: { p_project_id: string };
  Returns: ProjectSummary[];
};
get_material_price_stats: {
  Args: { p_material_id: string };
  Returns: MaterialPriceStats[];
};
```
  </action>
  <verify>
1. `cd material-price-intel && npx tsc --noEmit` passes with no type errors
2. All new types exported
3. Database.public.Tables includes all 4 new tables
4. Database.public.Functions includes both new RPCs
5. Generated column (variance_amount) excluded from Insert type
  </verify>
  <done>types.ts compiles clean with all estimating types. Database helper covers all new tables and RPCs.</done>
</task>

</tasks>

<verification>
1. Migration file 012_estimating_schema.sql exists with all 4 tables, RLS, indexes, triggers, RPCs
2. types.ts has all new types and Database helper updates
3. `npx tsc --noEmit` passes
4. No existing types or code broken
</verification>

<success_criteria>
- 4 new tables defined with proper constraints and FKs
- RLS policies enforce org scoping through join chains
- TypeScript types mirror SQL schema exactly
- Database helper type enables typed Supabase client usage for all new tables
- Both RPC functions typed and available
- Build passes with zero type errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-estimating-procurement/10-01-SUMMARY.md`
</output>
