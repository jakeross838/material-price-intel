---
phase: 03-ai-extraction
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - material-price-intel/supabase/functions/process-document/validation.ts
  - material-price-intel/supabase/functions/process-document/index.ts

autonomous: true

must_haves:
  truths:
    - "Cross-validation checks catch math errors: line qty * unit_price vs line_total, line totals sum vs subtotal, subtotal + tax + delivery vs grand total"
    - "Supplier is found-or-created using normalized_name matching before quote is saved"
    - "Extracted data is persisted to quotes and line_items tables with document status updated to completed or review_needed"
    - "Low-confidence extractions (overall < 0.7) set document status to review_needed instead of completed"
  artifacts:
    - path: "material-price-intel/supabase/functions/process-document/validation.ts"
      provides: "Cross-validation logic for extraction results"
      exports: ["validateExtraction", "ValidationResult"]
    - path: "material-price-intel/supabase/functions/process-document/index.ts"
      provides: "Complete Edge Function with persistence and validation"
      contains: "persistExtraction"
  key_links:
    - from: "index.ts"
      to: "validation.ts"
      via: "import validateExtraction"
      pattern: "import.*validateExtraction.*from.*validation"
    - from: "index.ts"
      to: "suppliers table"
      via: "find-or-create supplier by normalized_name"
      pattern: "from\\('suppliers'\\)"
    - from: "index.ts"
      to: "quotes table"
      via: "insert quote row"
      pattern: "from\\('quotes'\\)\\.insert"
    - from: "index.ts"
      to: "line_items table"
      via: "insert line item rows"
      pattern: "from\\('line_items'\\)\\.insert"
    - from: "index.ts"
      to: "complete_document RPC"
      via: "supabase.rpc('complete_document')"
      pattern: "rpc\\('complete_document'"
---

<objective>
Add cross-validation logic and database persistence to the Edge Function. After Claude extracts data, validate the math (line totals, subtotals, grand total), find-or-create the supplier, persist the quote and line items to the database, and update the document status.

Purpose: This completes the extraction pipeline end-to-end. After this plan, a document goes from 'pending' all the way to 'completed' (or 'review_needed' for low-confidence results) with structured data in the quotes and line_items tables.

Output: A validation module and updated Edge Function handler with full persistence logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-extraction/03-01-SUMMARY.md

Key schema context:
- suppliers table has UNIQUE(organization_id, normalized_name) constraint
- quotes table has confidence_score (NUMERIC 3,2), raw_extraction (JSONB), is_verified (BOOLEAN default false)
- line_items has sort_order (INT), material_id is null until normalization (Phase 5)
- complete_document(p_document_id, p_quote_id) sets status='completed' and links quote
- fail_document(p_document_id, p_error_message) sets status='failed'
- Document status enum: pending, processing, completed, failed, review_needed

Existing files to reference:
@material-price-intel/src/lib/types.ts
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/006_job_queue.sql
@material-price-intel/supabase/functions/process-document/index.ts
@material-price-intel/supabase/functions/process-document/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cross-validation module</name>
  <files>
    material-price-intel/supabase/functions/process-document/validation.ts
  </files>
  <action>
    Create a validation module that checks mathematical consistency of extracted data.

    **Export `ValidationResult` type:**
    ```typescript
    export type ValidationWarning = {
      field: string;       // e.g., "line_items[2].line_total", "totals.subtotal"
      expected: number;
      actual: number;
      message: string;
    };

    export type ValidationResult = {
      is_valid: boolean;        // true if no critical errors
      warnings: ValidationWarning[];
      adjusted_confidence: number; // overall confidence adjusted down for math errors
    };
    ```

    **Export `validateExtraction(extraction: ExtractionResult): ValidationResult`:**

    Import ExtractionResult from `./types.ts`.

    Perform these checks:

    1. **Line item math:** For each line item that has quantity, unit_price, and line_total:
       - If discount_pct or discount_amount exists: expected_total = (qty * unit_price) - discount
       - Otherwise: expected_total = qty * unit_price
       - If extended_price exists, check: extended_price == qty * unit_price (within tolerance)
       - Check: line_total matches expected_total (within tolerance)
       - Tolerance: allow 1% or $0.02, whichever is greater (handles rounding)
       - If mismatch, add a warning

    2. **Subtotal check:** If subtotal is present and at least 2 line items have line_total:
       - Sum all line_totals that are not null
       - Check: sum matches subtotal (within $1.00 tolerance -- quotes sometimes have adjustments)
       - If mismatch, add a warning

    3. **Grand total check:** If total_amount is present:
       - expected = (subtotal or sum_of_line_totals) + (tax_amount or 0) + (delivery_cost or 0)
       - Check: total_amount matches expected (within $1.00 tolerance)
       - If mismatch, add a warning

    4. **Tax rate check:** If both tax_amount and subtotal are present:
       - Computed rate = tax_amount / subtotal
       - If tax_rate is present, check it matches computed rate (within 0.005 tolerance)
       - If tax_rate is null but computed rate is between 0.06 and 0.08, note it's likely Florida 7%

    **Confidence adjustment:**
    - Start with `extraction.overall_confidence`
    - For each warning: reduce by 0.05 (max reduction 0.3)
    - Floor at 0.1

    **Helper function:** `isClose(a: number, b: number, tolerance: number): boolean` -- used for all numeric comparisons. Handle null/undefined gracefully (if either value is null, skip that check).

    **No external dependencies.** Pure TypeScript logic.
  </action>
  <verify>
    - File exists at `material-price-intel/supabase/functions/process-document/validation.ts`
    - Exports `validateExtraction` function and `ValidationResult` type
    - Checks line item math (qty * unit_price vs line_total)
    - Checks subtotal vs sum of line totals
    - Checks grand total vs subtotal + tax + delivery
    - Uses tolerance-based comparison (not exact equality)
    - Handles null values gracefully (skips checks when data missing)
    - Returns adjusted confidence score
  </verify>
  <done>
    Validation module catches mathematical inconsistencies in extracted data: line-level math, subtotal aggregation, and grand total composition. Each failure produces a descriptive warning and reduces the overall confidence score. Null values are handled gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add persistence logic and wire validation into Edge Function</name>
  <files>
    material-price-intel/supabase/functions/process-document/index.ts
  </files>
  <action>
    Update the Edge Function `index.ts` (created in Plan 01) to add data persistence after extraction. Read the existing file first, then add the following.

    **New imports:**
    - Import `validateExtraction` from `./validation.ts`
    - Import `ValidationResult` from `./validation.ts`

    **Add a `findOrCreateSupplier` async function:**
    ```typescript
    async function findOrCreateSupplier(
      supabase: SupabaseClient,
      organizationId: string,
      supplierData: ExtractedSupplier
    ): Promise<string> // returns supplier UUID
    ```
    Logic:
    1. Normalize the supplier name: `supplierData.name.trim().toLowerCase()` -> `normalizedName`
    2. Query: `supabase.from('suppliers').select('id').eq('organization_id', organizationId).eq('normalized_name', normalizedName).maybeSingle()`
    3. If found, return `data.id`
    4. If not found, insert new supplier:
       ```
       {
         organization_id: organizationId,
         name: supplierData.name.trim(),
         normalized_name: normalizedName,
         contact_name: supplierData.contact_name,
         contact_email: supplierData.contact_email,
         contact_phone: supplierData.contact_phone,
         address: supplierData.address,
       }
       ```
    5. Return the new supplier's id
    6. Handle unique constraint violation gracefully (race condition: another request created the supplier between our SELECT and INSERT). On conflict, re-query to get the id.

    **Add a `persistExtraction` async function:**
    ```typescript
    async function persistExtraction(
      supabase: SupabaseClient,
      documentId: string,
      organizationId: string,
      extraction: ExtractionResult,
      validation: ValidationResult,
      rawResponse: string
    ): Promise<string> // returns quote UUID
    ```
    Logic:
    1. Find or create supplier using `findOrCreateSupplier()`
    2. Determine final confidence: use `validation.adjusted_confidence`
    3. Insert quote:
       ```
       {
         organization_id: organizationId,
         document_id: documentId,
         supplier_id: supplierId,
         quote_number: extraction.quote_number,
         quote_date: extraction.quote_date,
         valid_until: extraction.valid_until,
         project_name: extraction.project_name,
         subtotal: extraction.totals.subtotal,
         delivery_cost: extraction.totals.delivery_cost,
         tax_amount: extraction.totals.tax_amount,
         tax_rate: extraction.totals.tax_rate,
         total_amount: extraction.totals.total_amount,
         payment_terms: extraction.payment_terms,
         notes: extraction.notes,
         confidence_score: validation.adjusted_confidence,
         raw_extraction: { extraction, validation_warnings: validation.warnings },
         is_verified: false,
       }
       ```
    4. Insert line items (batch insert all at once):
       ```
       extraction.line_items.map((item, index) => ({
         quote_id: quoteId,
         raw_description: item.raw_description,
         quantity: item.quantity,
         unit: item.unit,
         unit_price: item.unit_price,
         extended_price: item.extended_price,
         discount_pct: item.discount_pct,
         discount_amount: item.discount_amount,
         line_total: item.line_total,
         notes: item.notes,
         sort_order: index,
         material_id: null,  // Set during Phase 5 normalization
       }))
       ```
    5. Determine document final status:
       - If `validation.adjusted_confidence >= 0.7`: use 'completed'
       - If `validation.adjusted_confidence < 0.7`: use 'review_needed'
    6. Call the appropriate status update:
       - For 'completed': `supabase.rpc('complete_document', { p_document_id: documentId, p_quote_id: quoteId })`
       - For 'review_needed': Update document directly: `supabase.from('documents').update({ status: 'review_needed', quote_id: quoteId, completed_at: new Date().toISOString() }).eq('id', documentId)`
       (We can't use complete_document for review_needed because it hardcodes status='completed')
    7. Return quoteId

    **Update the main handler:**
    After the existing Claude API call and JSON parsing (from Plan 01), add:

    ```typescript
    // Validate extraction
    const validation = validateExtraction(parsedResult);

    // Persist to database
    const quoteId = await persistExtraction(
      supabase,
      document_id,
      document.organization_id,
      parsedResult,
      validation,
      responseText // raw Claude response for debugging
    );

    // Return success with validation info
    return new Response(JSON.stringify({
      success: true,
      document_id,
      quote_id: quoteId,
      confidence: validation.adjusted_confidence,
      warnings: validation.warnings,
      status: validation.adjusted_confidence >= 0.7 ? 'completed' : 'review_needed',
    }), {
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
    ```

    **Update error handling:** Make sure `fail_document` is called via RPC if any persistence step fails:
    ```typescript
    await supabase.rpc('fail_document', {
      p_document_id: document_id,
      p_error_message: `Persistence error: ${error.message}`
    });
    ```

    **IMPORTANT:** The Supabase client in Edge Functions uses the service role key, which bypasses RLS. This is intentional -- the Edge Function needs to write to suppliers, quotes, and line_items tables for any organization.
  </action>
  <verify>
    - `index.ts` imports validateExtraction from ./validation.ts
    - `findOrCreateSupplier` function exists and uses normalized_name for matching
    - `findOrCreateSupplier` handles unique constraint race condition
    - `persistExtraction` function inserts into quotes table with all fields mapped
    - `persistExtraction` function batch-inserts line items with sort_order
    - `persistExtraction` calls `complete_document` RPC for high-confidence results
    - `persistExtraction` updates document to 'review_needed' for low-confidence results
    - raw_extraction JSONB includes both the extraction and validation warnings
    - Error handling calls `fail_document` RPC on persistence failure
    - Response includes quote_id, confidence score, and validation warnings
  </verify>
  <done>
    Edge Function is complete end-to-end: extracts data via Claude, validates math consistency, finds or creates supplier, persists quote and line items, and updates document status to 'completed' (confidence >= 0.7) or 'review_needed' (confidence < 0.7). Validation warnings are stored in raw_extraction JSONB for review UI.
  </done>
</task>

</tasks>

<verification>
1. Validation module checks all three levels: line-item math, subtotal aggregation, grand total composition
2. Supplier find-or-create uses UNIQUE(organization_id, normalized_name) constraint
3. Quote row includes all schema fields: supplier_id, quote_number, quote_date, totals, confidence_score, raw_extraction
4. Line items batch-inserted with sort_order preserving original quote order
5. Document status transitions correctly: processing -> completed (high confidence) or review_needed (low confidence)
6. Failed extractions mark document as 'failed' with descriptive error
7. Validation warnings stored in raw_extraction for Phase 4 review UI
</verification>

<success_criteria>
- Complete extraction pipeline: document_id in -> validated quote + line items in database
- Cross-validation catches math errors and adjusts confidence accordingly
- Low-confidence results flagged with review_needed status
- Supplier dedup works via normalized_name
- All database writes use service role key (bypasses RLS)
- Error handling ensures document never stays in 'processing' state permanently
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-extraction/03-02-SUMMARY.md`
</output>
