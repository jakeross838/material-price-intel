---
phase: 03-ai-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/functions/process-document/index.ts
  - material-price-intel/supabase/functions/process-document/types.ts
  - material-price-intel/supabase/functions/process-document/prompt.ts

autonomous: true

must_haves:
  truths:
    - "Edge Function accepts a document_id, claims the document, downloads the PDF from Storage, and sends it to Claude"
    - "Claude receives a structured extraction prompt that handles both table-based and text-based quote layouts"
    - "Claude returns structured JSON with supplier info, line items, totals, and per-field confidence scores"
  artifacts:
    - path: "material-price-intel/supabase/functions/process-document/index.ts"
      provides: "Edge Function entry point with Deno.serve handler"
      contains: "Deno.serve"
    - path: "material-price-intel/supabase/functions/process-document/types.ts"
      provides: "TypeScript types for extraction request/response shapes"
      exports: ["ExtractionResult", "ExtractedSupplier", "ExtractedLineItem", "ExtractedTotals"]
    - path: "material-price-intel/supabase/functions/process-document/prompt.ts"
      provides: "System prompt and user prompt construction for Claude extraction"
      exports: ["buildExtractionMessages"]
  key_links:
    - from: "index.ts"
      to: "prompt.ts"
      via: "import buildExtractionMessages"
      pattern: "import.*buildExtractionMessages.*from.*prompt"
    - from: "index.ts"
      to: "Anthropic SDK"
      via: "new Anthropic() constructor with document content block"
      pattern: "new Anthropic|messages\\.create"
    - from: "index.ts"
      to: "Supabase Storage"
      via: "supabase.storage.from('documents').download()"
      pattern: "storage\\.from.*download"
    - from: "index.ts"
      to: "claim_pending_document / document lookup"
      via: "supabase.from('documents').select() or supabase.rpc('claim_pending_document')"
      pattern: "from\\('documents'\\)|rpc\\('claim_pending_document'\\)"
---

<objective>
Create the Supabase Edge Function that receives a document_id, retrieves the PDF from Storage, sends it to Claude Haiku 4.5 as a native document block, and receives structured extraction results.

Purpose: This is the core AI extraction engine -- the highest-value, highest-risk component of the entire system. The prompt must handle varied PDF layouts (formal tables and casual text quotes) and return structured JSON with confidence scores.

Output: Three files in `supabase/functions/process-document/` -- the Edge Function entry point, extraction types, and prompt construction module. After this plan, the Edge Function can call Claude and receive parsed results, but does NOT yet write to the database (that is Plan 02).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-upload-pipeline/02-01-SUMMARY.md
@.planning/phases/02-upload-pipeline/02-02-SUMMARY.md

Key context from prior phases:
- Storage bucket is named 'documents', paths are `{org_id}/{uuid}_{filename}`
- Job queue functions: `claim_pending_document()`, `complete_document(p_document_id, p_quote_id)`, `fail_document(p_document_id, p_error_message)` -- all SECURITY DEFINER
- Document status flow: pending -> processing -> completed/failed/review_needed
- Types defined in src/lib/types.ts (Quote, LineItem, Supplier, Document types)

Existing files to reference:
@material-price-intel/src/lib/types.ts
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/006_job_queue.sql
@material-price-intel/supabase/config.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extraction types and prompt module</name>
  <files>
    material-price-intel/supabase/functions/process-document/types.ts
    material-price-intel/supabase/functions/process-document/prompt.ts
  </files>
  <action>
    **IMPORTANT: These are Deno files (Supabase Edge Functions run Deno 2). Do NOT use Node.js imports or npm packages. Use `https://esm.sh/` or `npm:` specifiers for external deps.**

    **types.ts** -- Define the structured extraction result types:

    ```typescript
    // Confidence is tracked at the line-item level (per ExtractedLineItem.confidence)
    // and overall extraction level (ExtractionResult.overall_confidence).
    // Per INGEST-04, "low-confidence items flagged" means line items with confidence < 0.7
    // are highlighted in the Phase 4 review UI.

    export type ExtractedSupplier = {
      name: string;
      contact_name: string | null;
      contact_email: string | null;
      contact_phone: string | null;
      address: string | null;
    };

    export type ExtractedLineItem = {
      raw_description: string;
      quantity: number | null;
      unit: string | null; // 'pc', 'lf', 'bf', 'sqft', 'ea', 'bundle', etc.
      unit_price: number | null;
      extended_price: number | null; // qty * unit_price before discount
      discount_pct: number | null;
      discount_amount: number | null;
      line_total: number | null; // final amount for this line
      notes: string | null;
      confidence: number; // 0.0-1.0, overall confidence for this line
    };

    export type ExtractedTotals = {
      subtotal: number | null;
      delivery_cost: number | null;
      tax_amount: number | null;
      tax_rate: number | null; // as decimal, e.g. 0.07 for 7%
      total_amount: number | null;
    };

    export type ExtractionResult = {
      supplier: ExtractedSupplier;
      quote_number: string | null;
      quote_date: string | null; // ISO date string YYYY-MM-DD
      valid_until: string | null; // ISO date string YYYY-MM-DD
      project_name: string | null;
      payment_terms: string | null;
      notes: string | null;
      line_items: ExtractedLineItem[];
      totals: ExtractedTotals;
      overall_confidence: number; // 0.0-1.0, average across all fields
      extraction_notes: string | null; // any issues Claude noticed
    };
    ```

    **prompt.ts** -- Build the extraction prompt:

    Export a function `buildExtractionMessages()` that returns the system and user message array for Claude's `messages.create()` call. The function takes the base64-encoded PDF data and its media type.

    The system prompt MUST:
    1. Instruct Claude it is a construction material quote extraction engine
    2. Describe the EXACT JSON schema it must return (matching ExtractionResult)
    3. Explain confidence scoring: 1.0 = clearly visible and unambiguous, 0.7-0.9 = readable but some interpretation needed, 0.3-0.6 = partially visible or inferred, below 0.3 = guessed or not found
    4. Handle both formal PDF tables (structured rows/columns) and casual text quotes ("Hey Greg, here's pricing...")
    5. Instruct to extract ALL line items, not just a sample
    6. Instruct to normalize units to short codes: pc, lf, bf, sqft, ea, bundle, sheet, bag, roll, gal, box
    7. Instruct that dates should be YYYY-MM-DD format
    8. Instruct that all monetary values should be plain numbers (no $ signs, no commas)
    9. Instruct to set null for fields that are genuinely not present (not 0, not empty string)
    10. Instruct to return ONLY the JSON object, no markdown fencing, no explanation text

    The user message MUST:
    1. Include the PDF as a document content block: `{ type: "document", source: { type: "base64", media_type: "application/pdf", data: base64Data } }`
    2. Include a text block: "Extract all data from this supplier quote. Return the JSON extraction result."

    Return format: `{ system: string, messages: MessageParam[] }` compatible with the Anthropic SDK's `messages.create()` parameters.
  </action>
  <verify>
    - Both files exist in `material-price-intel/supabase/functions/process-document/`
    - types.ts exports ExtractionResult, ExtractedSupplier, ExtractedLineItem, ExtractedTotals
    - prompt.ts exports buildExtractionMessages function
    - prompt.ts system prompt includes JSON schema description matching the types
    - prompt.ts user message includes document content block structure
    - No Node.js-specific imports (no `require()`, no bare `import from 'package'` without npm: or https://esm.sh/)
  </verify>
  <done>
    Types file defines the complete extraction result schema. Prompt module constructs a detailed system prompt covering both table and text quote formats, confidence scoring rules, unit normalization, and JSON-only output. User message includes the PDF as a native document block.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Edge Function handler with PDF retrieval and Claude API call</name>
  <files>
    material-price-intel/supabase/functions/process-document/index.ts
  </files>
  <action>
    **IMPORTANT: This is a Deno Edge Function. Use `npm:` specifiers for npm packages.**

    Create the Edge Function entry point `index.ts` using `Deno.serve()`.

    **Imports:**
    - `import Anthropic from "npm:@anthropic-ai/sdk@latest";` (Anthropic SDK via npm: specifier for Deno)
    - `import { createClient } from "npm:@supabase/supabase-js@2";` (Supabase client)
    - Import types from `./types.ts`
    - Import `buildExtractionMessages` from `./prompt.ts`

    **Handler flow:**

    1. **Parse request:** Extract `{ document_id }` from the JSON body. If missing, return 400.

    2. **Create Supabase client:** Use `Deno.env.get('SUPABASE_URL')` and `Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')` (service role key, NOT anon key -- Edge Functions need elevated access to bypass RLS for cross-table operations). These env vars are automatically available in Supabase Edge Functions.

    3. **Fetch the document record:** Query `documents` table by `document_id`. Verify it exists. If status is not 'pending' and not 'processing', return 400 with message "Document is not in a processable state".

    4. **Update status to processing:** If the document is still 'pending', update its status to 'processing' and set `started_at = new Date().toISOString()`. (If it is already 'processing' from a prior claim, skip this step -- allows retry.)

    5. **Download PDF from Storage:** Use `supabase.storage.from('documents').download(document.file_path)`. Convert the resulting Blob to a Uint8Array, then to a base64 string. Use `btoa(String.fromCharCode(...uint8Array))` for the base64 encoding -- but note for large files this may hit stack limits. Instead, use a chunked approach:
       ```typescript
       const uint8Array = new Uint8Array(await blob.arrayBuffer());
       let binary = '';
       const chunkSize = 8192;
       for (let i = 0; i < uint8Array.length; i += chunkSize) {
         const chunk = uint8Array.subarray(i, i + chunkSize);
         binary += String.fromCharCode(...chunk);
       }
       const base64Data = btoa(binary);
       ```

    6. **Call Claude API:**
       ```typescript
       const anthropic = new Anthropic({
         apiKey: Deno.env.get('ANTHROPIC_API_KEY')!,
       });
       const { system, messages } = buildExtractionMessages(base64Data);
       const response = await anthropic.messages.create({
         model: 'claude-haiku-4-5-20250315',
         max_tokens: 16384, // large enough for quotes with 50+ line items
         system,
         messages,
       });
       ```
       NOTE on model: Use `claude-haiku-4-5-20250315` -- this is the Claude Haiku 4.5 model ID. It is cost-efficient and capable enough for structured extraction.

    7. **Parse Claude's response:** Extract the text content from `response.content[0]` (type 'text'). Parse it as JSON into `ExtractionResult`. Wrap in try-catch -- if JSON parsing fails, call `fail_document()` with the parse error and the raw response text.

    8. **Return the extraction result** as JSON response (200). Include the document_id and the parsed ExtractionResult in the response body. Do NOT persist to database yet -- Plan 02 will add that logic.

    9. **Error handling:** Wrap the entire handler in try-catch. On any error:
       - If we have a document_id and supabase client, call `fail_document(document_id, error.message)` via RPC
       - Return 500 with error message

    **Response format:**
    ```typescript
    return new Response(JSON.stringify({
      success: true,
      document_id,
      extraction: parsedResult,
    }), {
      headers: { 'Content-Type': 'application/json' },
    });
    ```

    **CORS headers:** Add CORS headers to support client-side invocation:
    ```typescript
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    };
    ```
    Handle OPTIONS preflight requests. Include corsHeaders in all responses.
  </action>
  <verify>
    - File exists at `material-price-intel/supabase/functions/process-document/index.ts`
    - Uses `Deno.serve()` (not `serve()` from std library)
    - Imports Anthropic SDK via `npm:@anthropic-ai/sdk`
    - Imports Supabase client via `npm:@supabase/supabase-js@2`
    - Creates Supabase client with `SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` env vars
    - Downloads PDF from Storage bucket 'documents'
    - Converts PDF to base64 using chunked approach (not single spread)
    - Calls `anthropic.messages.create()` with model `claude-haiku-4-5-20250315`
    - Passes PDF as document content block in messages
    - Parses response JSON into ExtractionResult type
    - Has CORS headers and OPTIONS handler
    - Error handling calls fail_document RPC on failure
    - `npm run build` in the React app still passes (Edge Function is separate, but no syntax errors in shared types)
  </verify>
  <done>
    Edge Function entry point handles the full extraction flow: receive document_id, fetch document record, download PDF from Storage, convert to base64, send to Claude Haiku 4.5 with structured extraction prompt, parse JSON response. Returns extraction result. Errors are caught and reported via fail_document(). CORS enabled for client-side invocation.
  </done>
</task>

</tasks>

<verification>
1. All three files exist in `material-price-intel/supabase/functions/process-document/`
2. Types define the complete extraction schema (supplier, line items, totals, confidence)
3. Prompt includes comprehensive instructions for varied quote formats
4. Edge Function handler covers the full flow: request -> document fetch -> PDF download -> base64 -> Claude API -> parse response
5. No Node.js-specific patterns (uses Deno.serve, npm: specifiers, Deno.env)
6. Error handling wraps entire flow with fail_document() fallback
</verification>

<success_criteria>
- Edge Function code is complete and could be deployed with `supabase functions deploy process-document`
- Claude receives the PDF as a native document block (not text extraction)
- Extraction prompt handles both formal table PDFs and casual text quotes
- Response is parsed into strongly-typed ExtractionResult
- On failure, document status is updated to 'failed' with error message
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-extraction/03-01-SUMMARY.md`
</output>
