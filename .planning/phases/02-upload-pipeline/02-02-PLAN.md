---
phase: 02-upload-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - material-price-intel/src/hooks/useDocumentStatus.ts
  - material-price-intel/src/components/documents/RecentUploads.tsx
  - material-price-intel/src/pages/UploadPage.tsx
  - material-price-intel/supabase/migrations/006_job_queue.sql
autonomous: true

must_haves:
  truths:
    - "Processing status updates appear in the UI without page refresh"
    - "User can see a list of recently uploaded documents with their current status"
    - "Document status badges show the correct state (pending, processing, completed, failed)"
    - "Job queue SQL infrastructure exists for polling pending documents"
  artifacts:
    - path: "material-price-intel/src/hooks/useDocumentStatus.ts"
      provides: "Supabase Realtime subscription for document status changes"
      exports: ["useDocumentStatus", "useRecentDocuments"]
    - path: "material-price-intel/src/components/documents/RecentUploads.tsx"
      provides: "Recent uploads list with status badges"
      exports: ["RecentUploads"]
    - path: "material-price-intel/supabase/migrations/006_job_queue.sql"
      provides: "SQL function to claim and process pending documents"
      contains: "claim_pending_document"
  key_links:
    - from: "material-price-intel/src/hooks/useDocumentStatus.ts"
      to: "supabase.channel()"
      via: "Realtime subscription"
      pattern: "supabase\\.channel.*postgres_changes"
    - from: "material-price-intel/src/components/documents/RecentUploads.tsx"
      to: "material-price-intel/src/hooks/useDocumentStatus.ts"
      via: "useRecentDocuments hook"
      pattern: "useRecentDocuments"
    - from: "material-price-intel/src/pages/UploadPage.tsx"
      to: "material-price-intel/src/components/documents/RecentUploads.tsx"
      via: "Component rendering"
      pattern: "<RecentUploads"
---

<objective>
Add real-time document status tracking and job queue infrastructure. After uploading a PDF, the user sees live status updates as documents move through the processing pipeline, and the database has the SQL infrastructure to support async processing.

Purpose: Completes the upload experience by showing processing progress and prepares the database for Phase 3's AI extraction pipeline. Without this, uploads disappear into a void with no feedback.

Output: Realtime-powered document status UI, recent uploads list, and job queue SQL migration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan summary for upload page structure
@.planning/phases/02-upload-pipeline/02-01-SUMMARY.md

# Key source files
@material-price-intel/src/lib/supabase.ts
@material-price-intel/src/lib/types.ts
@material-price-intel/src/hooks/useAuth.ts
@material-price-intel/src/pages/UploadPage.tsx
@material-price-intel/src/hooks/useUploadDocument.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Realtime document status hooks and recent uploads component</name>
  <files>
    material-price-intel/src/hooks/useDocumentStatus.ts
    material-price-intel/src/components/documents/RecentUploads.tsx
    material-price-intel/src/pages/UploadPage.tsx
  </files>
  <action>
    **Step 1: Create `src/hooks/useDocumentStatus.ts`**

    This file exports two hooks:

    **`useDocumentStatus(documentId: string | null)`**
    - Subscribes to Realtime changes for a specific document
    - Returns `{ document: Document | null, loading: boolean }`
    - Uses Supabase Realtime channel subscription:
      ```typescript
      const channel = supabase
        .channel(`document-${documentId}`)
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'documents',
            filter: `id=eq.${documentId}`,
          },
          (payload) => {
            setDocument(payload.new as Document);
          }
        )
        .subscribe();
      ```
    - Clean up subscription on unmount or when documentId changes: `supabase.removeChannel(channel)`
    - Initially fetch the document once via `.from('documents').select().eq('id', documentId).single()` to get current state, then listen for updates

    **`useRecentDocuments(limit: number = 10)`**
    - Fetches recent documents for the current user's organization
    - Uses React Query (`useQuery`) for initial fetch:
      ```typescript
      const { data, isLoading, refetch } = useQuery({
        queryKey: ['documents', 'recent'],
        queryFn: async () => {
          const { data, error } = await supabase
            .from('documents')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(limit);
          if (error) throw error;
          return data as Document[];
        },
      });
      ```
    - Subscribes to Realtime for ALL document changes (inserts and updates) for the organization:
      ```typescript
      const channel = supabase
        .channel('recent-documents')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'documents',
          },
          () => {
            // Refetch the query to get updated data
            queryClient.invalidateQueries({ queryKey: ['documents', 'recent'] });
          }
        )
        .subscribe();
      ```
    - Use `useQueryClient()` to invalidate on realtime events
    - Clean up Realtime channel on unmount
    - Returns `{ documents: Document[], isLoading: boolean }`

    Note: Organization scoping is enforced by RLS policies at the database level (`004_rls_policies.sql`). No client-side org filter needed â€” the Supabase client only returns rows the authenticated user's organization can see.

    Import `Document` type from `@/lib/types`. Import supabase from `@/lib/supabase`.

    **Step 2: Create `src/components/documents/RecentUploads.tsx`**

    A component that shows a list of recent document uploads with status badges.

    The component should:
    1. Use `useRecentDocuments()` hook to get document list
    2. Show a "Recent Uploads" heading
    3. If loading, show a simple skeleton/loading state
    4. If no documents, show "No documents uploaded yet" message
    5. For each document, show a row/card with:
       - File icon (FileText from lucide-react)
       - File name (truncated if long)
       - File size (formatted: "2.4 MB")
       - Upload timestamp (relative: "2 minutes ago" using date-fns `formatDistanceToNow`)
       - Status badge with color coding:
         - `pending`: yellow/amber badge, text "Pending"
         - `processing`: blue badge with a subtle pulse animation, text "Processing"
         - `completed`: green badge, text "Completed"
         - `failed`: red badge, text "Failed" (show error_message on hover if available)
         - `review_needed`: orange badge, text "Review Needed"

    Use Tailwind classes for badges (no need for a shadcn Badge component -- simple `<span>` with rounded-full, px-2, py-0.5, text-xs, font-medium, and color classes).

    Format file size with a simple utility:
    ```typescript
    function formatFileSize(bytes: number | null): string {
      if (!bytes) return 'Unknown size';
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }
    ```

    **Step 3: Integrate RecentUploads into UploadPage.tsx**

    Add the `<RecentUploads />` component below the drag-and-drop zone on the upload page:
    - Add a visual separator (margin/spacing) between the upload zone and the recent uploads list
    - The recent uploads list should be in a Card or simple section below

    This should be a simple addition -- import and render `<RecentUploads />` after the existing upload zone JSX.
  </action>
  <verify>
    1. `cd material-price-intel && npm run build` completes with zero TypeScript errors
    2. `npm run dev` -- navigate to /upload, verify "Recent Uploads" section appears below the drop zone
    3. If documents exist in the database, they should appear with status badges
    4. Upload a new file -- it should appear in the recent uploads list automatically (Realtime)
    5. Manually update a document's status in Supabase dashboard -- the badge should update in the UI without refresh
  </verify>
  <done>
    - useDocumentStatus hook subscribes to single-document Realtime updates
    - useRecentDocuments hook fetches recent documents and subscribes to Realtime for live updates
    - RecentUploads component renders document list with color-coded status badges
    - Upload page shows recent uploads below the drag-and-drop zone
    - New uploads appear in the list automatically via Realtime
    - Status changes reflected in UI without page refresh
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job queue SQL migration</name>
  <files>
    material-price-intel/supabase/migrations/006_job_queue.sql
  </files>
  <action>
    Create a SQL migration file that sets up the job queue infrastructure for processing pending documents. This is the database-side preparation for Phase 3's AI extraction pipeline.

    **File: `supabase/migrations/006_job_queue.sql`**

    Create a `claim_pending_document()` function that atomically claims the next pending document for processing. This prevents double-processing if multiple workers exist:

    ```sql
    -- ===========================================
    -- JOB QUEUE: Claim next pending document for processing
    -- ===========================================
    -- Atomically claims the oldest pending document by setting its status
    -- to 'processing' and recording the start time. Returns the claimed
    -- document row, or NULL if no pending documents exist.
    --
    -- Usage (from Edge Function or cron job):
    --   SELECT * FROM claim_pending_document();
    --
    -- The atomic UPDATE ... RETURNING prevents race conditions when
    -- multiple workers poll simultaneously.
    -- ===========================================

    CREATE OR REPLACE FUNCTION claim_pending_document()
    RETURNS SETOF documents AS $$
      UPDATE documents
      SET status = 'processing',
          started_at = NOW()
      WHERE id = (
        SELECT id FROM documents
        WHERE status = 'pending'
        ORDER BY created_at ASC
        LIMIT 1
        FOR UPDATE SKIP LOCKED
      )
      RETURNING *;
    $$ LANGUAGE sql VOLATILE SECURITY DEFINER;

    -- ===========================================
    -- JOB QUEUE: Mark document as completed
    -- ===========================================
    CREATE OR REPLACE FUNCTION complete_document(
      p_document_id UUID,
      p_quote_id UUID DEFAULT NULL
    )
    RETURNS VOID AS $$
      UPDATE documents
      SET status = 'completed',
          completed_at = NOW(),
          quote_id = COALESCE(p_quote_id, quote_id)
      WHERE id = p_document_id;
    $$ LANGUAGE sql VOLATILE SECURITY DEFINER;

    -- ===========================================
    -- JOB QUEUE: Mark document as failed
    -- ===========================================
    CREATE OR REPLACE FUNCTION fail_document(
      p_document_id UUID,
      p_error_message TEXT
    )
    RETURNS VOID AS $$
      UPDATE documents
      SET status = 'failed',
          error_message = p_error_message,
          completed_at = NOW()
      WHERE id = p_document_id;
    $$ LANGUAGE sql VOLATILE SECURITY DEFINER;
    ```

    Key design decisions:
    - `FOR UPDATE SKIP LOCKED`: Prevents double-claiming in concurrent scenarios (standard PostgreSQL advisory locking pattern for job queues)
    - `SECURITY DEFINER`: These functions run with the definer's permissions, allowing Edge Functions to call them without needing direct table access beyond RLS
    - `RETURNS SETOF documents`: Returns the full document row so the caller has all the info needed to process (file_path, etc.)
    - No pg_cron setup: For v1 with a single user, the processing trigger will be an Edge Function called after upload (Phase 3) rather than a cron-based poller. The `claim_pending_document()` pattern still works for this -- the Edge Function calls it to claim work. pg_cron can be added later if batch processing is needed.
    - `complete_document` and `fail_document` are convenience functions that Phase 3's Edge Function will call

    **Important:** This migration file is numbered 006 to follow the existing migration sequence (001-005 from Phase 1). The file goes in `material-price-intel/supabase/migrations/`.

    **Note about Supabase Realtime:** For Realtime to work on the `documents` table, the table must have Realtime enabled. Add this to the migration:

    ```sql
    -- ===========================================
    -- ENABLE REALTIME for documents table
    -- ===========================================
    -- Required for Supabase Realtime subscriptions to receive
    -- postgres_changes events on the documents table.
    ALTER PUBLICATION supabase_realtime ADD TABLE documents;
    ```
  </action>
  <verify>
    1. File exists at `material-price-intel/supabase/migrations/006_job_queue.sql`
    2. SQL syntax is valid (no obvious errors)
    3. The migration defines three functions: claim_pending_document, complete_document, fail_document
    4. Realtime is enabled for documents table via ALTER PUBLICATION
    5. The user should apply this migration to Supabase (either via `supabase db push` or manually in SQL editor)
  </verify>
  <done>
    - claim_pending_document() atomically claims oldest pending document
    - complete_document() marks a document as completed with optional quote_id
    - fail_document() marks a document as failed with error message
    - Realtime enabled for documents table
    - Migration file follows existing naming convention (006 after 005)
  </done>
</task>

</tasks>

<verification>
1. `npm run build` in material-price-intel/ passes with zero errors
2. /upload page shows both the drag-and-drop zone AND recent uploads list
3. Upload a PDF -- it appears in recent uploads immediately with "Pending" status badge
4. In Supabase SQL editor, run `UPDATE documents SET status = 'processing' WHERE id = (SELECT id FROM documents WHERE status = 'pending' LIMIT 1)` -- the UI updates the badge to "Processing" without page refresh
5. Migration file 006_job_queue.sql exists with claim_pending_document, complete_document, fail_document functions
6. After applying migration, `SELECT * FROM claim_pending_document()` returns a pending document and sets it to processing
</verification>

<success_criteria>
- Document status changes are reflected in UI via Supabase Realtime (no page refresh needed)
- Recent uploads list shows documents with color-coded status badges
- New uploads appear in the list automatically
- Job queue functions exist for Phase 3 to use (claim, complete, fail)
- Realtime is enabled on the documents table
</success_criteria>

<output>
After completion, create `.planning/phases/02-upload-pipeline/02-02-SUMMARY.md`
</output>
