---
phase: 09-smart-accuracy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/migrations/010_line_type_and_effective_price.sql
  - material-price-intel/src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "line_items table has a line_type column with CHECK constraint for valid values"
    - "line_items table has an effective_unit_price column"
    - "quotes table has a quote_discount_pct and quote_discount_amount column for quote-wide discounts"
    - "update_quote_review RPC handles line_type, effective_unit_price, AND applies_to_line_item_id on insert"
    - "update_quote_review RPC updates quote_discount_pct and quote_discount_amount on the quotes table"
    - "Client-side LineItem type includes line_type and effective_unit_price fields"
    - "Database type helper includes the new columns in Insert and Row types"
  artifacts:
    - path: "material-price-intel/supabase/migrations/010_line_type_and_effective_price.sql"
      provides: "Schema migration adding line_type, effective_unit_price, quote-level discount columns"
      contains: "line_type"
    - path: "material-price-intel/src/lib/types.ts"
      provides: "Updated LineItem and Quote types with new fields"
      contains: "line_type"
  key_links:
    - from: "migrations/010_line_type_and_effective_price.sql"
      to: "line_items table"
      via: "ALTER TABLE ADD COLUMN"
      pattern: "ALTER TABLE line_items ADD COLUMN"
    - from: "src/lib/types.ts"
      to: "Supabase client queries"
      via: "TypeScript type used by all queries"
      pattern: "line_type.*LineItemType"
---

<objective>
Add the database columns and TypeScript types needed for line item classification and effective pricing.

Purpose: This is the foundation for all Phase 9 work. The line_type column enables the AI to classify items as material/discount/fee/subtotal_line/note, and effective_unit_price stores the post-discount price for accurate comparisons. Quote-level discount columns support distributing quote-wide discounts proportionally.

Output: A SQL migration file and updated TypeScript types that all subsequent plans build on.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/008_approved_status_and_rpc.sql
@material-price-intel/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for line_type, effective_unit_price, and quote-level discount columns</name>
  <files>material-price-intel/supabase/migrations/010_line_type_and_effective_price.sql</files>
  <action>
Create a new migration file `010_line_type_and_effective_price.sql` that:

1. **Add line_type column to line_items:**
   ```sql
   ALTER TABLE line_items ADD COLUMN line_type TEXT NOT NULL DEFAULT 'material'
     CHECK (line_type IN ('material', 'discount', 'fee', 'subtotal_line', 'note'));
   ```
   Default is 'material' so all existing rows get classified as material (safe default -- the backfill migration in Plan 04 will reclassify them properly).

2. **Add effective_unit_price column to line_items:**
   ```sql
   ALTER TABLE line_items ADD COLUMN effective_unit_price NUMERIC(12,4);
   ```
   This stores the post-discount unit price. NULL means no discount applied (effective = unit_price).

3. **Add applies_to_line_item_id column to line_items** (for discount attribution):
   ```sql
   ALTER TABLE line_items ADD COLUMN applies_to_line_item_id UUID REFERENCES line_items(id) ON DELETE SET NULL;
   ```
   When a discount line is attributed to a specific material line, this FK points to it. NULL means quote-wide or unattributed.

4. **Add quote-level discount columns to quotes:**
   ```sql
   ALTER TABLE quotes ADD COLUMN quote_discount_pct NUMERIC(5,2);
   ALTER TABLE quotes ADD COLUMN quote_discount_amount NUMERIC(12,2);
   ```
   For quote-wide discounts that aren't attributable to a single line item.

5. **Update the update_quote_review RPC** to handle the new fields:

   **CRITICAL: The INSERT must include line_type, effective_unit_price, AND applies_to_line_item_id.**

   **CRITICAL: The UPDATE quotes SET clause must include quote_discount_pct and quote_discount_amount.**

   ```sql
   CREATE OR REPLACE FUNCTION update_quote_review(
     p_quote_id UUID,
     p_quote_number TEXT DEFAULT NULL,
     p_quote_date DATE DEFAULT NULL,
     p_project_name TEXT DEFAULT NULL,
     p_payment_terms TEXT DEFAULT NULL,
     p_valid_until DATE DEFAULT NULL,
     p_notes TEXT DEFAULT NULL,
     p_subtotal NUMERIC DEFAULT NULL,
     p_delivery_cost NUMERIC DEFAULT NULL,
     p_tax_amount NUMERIC DEFAULT NULL,
     p_tax_rate NUMERIC DEFAULT NULL,
     p_total_amount NUMERIC DEFAULT NULL,
     p_line_items JSONB DEFAULT NULL,
     p_quote_discount_pct NUMERIC DEFAULT NULL,
     p_quote_discount_amount NUMERIC DEFAULT NULL
   )
   RETURNS VOID AS $$
   DECLARE
     item JSONB;
     i INT := 0;
   BEGIN
     -- existing ownership check unchanged --

     -- Update quote scalar fields (only non-null params)
     UPDATE quotes SET
       quote_number = COALESCE(p_quote_number, quote_number),
       quote_date = COALESCE(p_quote_date, quote_date),
       project_name = COALESCE(p_project_name, project_name),
       payment_terms = COALESCE(p_payment_terms, payment_terms),
       valid_until = COALESCE(p_valid_until, valid_until),
       notes = COALESCE(p_notes, notes),
       subtotal = COALESCE(p_subtotal, subtotal),
       delivery_cost = COALESCE(p_delivery_cost, delivery_cost),
       tax_amount = COALESCE(p_tax_amount, tax_amount),
       tax_rate = COALESCE(p_tax_rate, tax_rate),
       total_amount = COALESCE(p_total_amount, total_amount),
       quote_discount_pct = COALESCE(p_quote_discount_pct, quote_discount_pct),
       quote_discount_amount = COALESCE(p_quote_discount_amount, quote_discount_amount)
     WHERE id = p_quote_id
       AND organization_id = public.user_org_id();

     -- Replace line items if provided
     IF p_line_items IS NOT NULL THEN
       DELETE FROM line_items WHERE quote_id = p_quote_id;
       FOR item IN SELECT * FROM jsonb_array_elements(p_line_items)
       LOOP
         INSERT INTO line_items (
           quote_id, raw_description, quantity, unit, unit_price,
           extended_price, discount_pct, discount_amount, line_total,
           notes, sort_order, material_id, line_type, effective_unit_price,
           applies_to_line_item_id
         ) VALUES (
           p_quote_id,
           item->>'raw_description',
           (item->>'quantity')::NUMERIC,
           item->>'unit',
           (item->>'unit_price')::NUMERIC,
           (item->>'extended_price')::NUMERIC,
           (item->>'discount_pct')::NUMERIC,
           (item->>'discount_amount')::NUMERIC,
           (item->>'line_total')::NUMERIC,
           item->>'notes',
           i,
           NULL,
           COALESCE(item->>'line_type', 'material'),
           (item->>'effective_unit_price')::NUMERIC,
           NULL
         );
         i := i + 1;
       END LOOP;
     END IF;
   END;
   $$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;
   ```

   **NOTE on applies_to_line_item_id:** The RPC uses DELETE+INSERT which creates new row IDs each save. This means `applies_to_line_item_id` FK references are destroyed on every review save cycle. The INSERT sets it to NULL. This is an accepted limitation: discount attribution is set during initial AI extraction (Plan 03) and is lost if the user re-saves in the Review UI. The description-based discount attribution from the AI is the source of truth; the FK is a convenience for queries. If needed in the future, this could be addressed by switching to an UPSERT pattern or re-linking by sort_order after INSERT, but that complexity is out of scope for Phase 9.

6. **Add an index on line_type** for filtering queries:
   ```sql
   CREATE INDEX idx_line_items_line_type ON line_items(line_type);
   ```

7. **Backfill effective_unit_price for existing rows** where discount data exists:
   ```sql
   UPDATE line_items
   SET effective_unit_price = CASE
     WHEN discount_amount IS NOT NULL AND quantity IS NOT NULL AND quantity > 0
       THEN unit_price - (discount_amount / quantity)
     WHEN discount_pct IS NOT NULL
       THEN unit_price * (1 - discount_pct / 100)
     ELSE unit_price
   END
   WHERE unit_price IS NOT NULL;
   ```

Do NOT drop any existing columns. This is purely additive.
  </action>
  <verify>
Read the migration file and verify:
- line_type column with CHECK constraint for all 5 values
- effective_unit_price column with NUMERIC(12,4)
- applies_to_line_item_id self-referencing FK
- quote-level discount columns on quotes table
- Updated update_quote_review RPC includes ALL THREE new line_item columns: line_type, effective_unit_price, applies_to_line_item_id
- Updated update_quote_review RPC UPDATE quotes SET clause includes quote_discount_pct and quote_discount_amount
- RPC has new parameters p_quote_discount_pct and p_quote_discount_amount
- Index on line_type
- Backfill UPDATE statement
  </verify>
  <done>Migration file exists at material-price-intel/supabase/migrations/010_line_type_and_effective_price.sql with all schema changes and complete RPC update including applies_to_line_item_id in INSERT and quote_discount columns in UPDATE</done>
</task>

<task type="auto">
  <name>Task 2: Update client-side TypeScript types for new columns</name>
  <files>material-price-intel/src/lib/types.ts</files>
  <action>
Update `material-price-intel/src/lib/types.ts`:

1. **Add LineItemType union type** before the LineItem type:
   ```typescript
   export type LineItemType = 'material' | 'discount' | 'fee' | 'subtotal_line' | 'note';
   ```

2. **Add new fields to LineItem type:**
   ```typescript
   export type LineItem = {
     id: string;
     quote_id: string;
     material_id: string | null;
     raw_description: string;
     quantity: number | null;
     unit: string | null;
     unit_price: number | null;
     extended_price: number | null;
     discount_pct: number | null;
     discount_amount: number | null;
     line_total: number | null;
     notes: string | null;
     sort_order: number;
     line_type: LineItemType;           // NEW
     effective_unit_price: number | null; // NEW
     applies_to_line_item_id: string | null; // NEW
     created_at: string;
   };
   ```

3. **Add quote-level discount fields to Quote type:**
   ```typescript
   export type Quote = {
     // ... all existing fields ...
     quote_discount_pct: number | null;    // NEW
     quote_discount_amount: number | null; // NEW
     // ... created_at, updated_at unchanged ...
   };
   ```

4. **Update Database type helper** for line_items table:
   - Row type already references LineItem (good)
   - Update Insert type to include the new fields: `Omit<LineItem, "id" | "created_at">` already handles this since LineItem now includes the new fields
   - Update quotes Insert/Update similarly (already handled by Omit pattern)

5. **Update the Database.Functions.update_quote_review Args type** to reflect that line items in the JSON can now include line_type:
   No change needed here since p_line_items is typed as `string | null` (JSON string).

Ensure the existing type structure is preserved exactly. Only ADD new fields; do not rename or remove anything.
  </action>
  <verify>
Run `npx tsc --noEmit` from `material-price-intel/` directory (if tsconfig is configured). If not available, manually verify by reading the file:
- LineItemType union type exists with 5 values
- LineItem has line_type, effective_unit_price, applies_to_line_item_id fields
- Quote has quote_discount_pct and quote_discount_amount fields
- All existing fields remain unchanged
  </verify>
  <done>LineItem type includes line_type (LineItemType), effective_unit_price (number | null), applies_to_line_item_id (string | null). Quote type includes quote_discount_pct and quote_discount_amount. LineItemType union type exported.</done>
</task>

</tasks>

<verification>
- Migration SQL file is syntactically valid (no SQL errors on review)
- All new columns have appropriate types and constraints
- TypeScript types match the SQL schema exactly
- No existing fields removed or renamed
- update_quote_review RPC updated to persist line_type, effective_unit_price, AND applies_to_line_item_id
- update_quote_review RPC updates quote_discount_pct and quote_discount_amount on the quotes table
</verification>

<success_criteria>
1. Migration file exists with all 7 schema changes (line_type, effective_unit_price, applies_to_line_item_id, quote_discount_pct, quote_discount_amount, index, backfill, RPC update)
2. RPC INSERT includes all three new line_item columns (line_type, effective_unit_price, applies_to_line_item_id)
3. RPC UPDATE quotes SET includes quote_discount_pct and quote_discount_amount
4. TypeScript types updated with LineItemType union and all new fields on LineItem and Quote
5. No breaking changes to existing code -- all additions are backward-compatible (defaults, nullable)
</success_criteria>

<output>
After completion, create `.planning/phases/09-smart-accuracy/09-01-SUMMARY.md`
</output>
