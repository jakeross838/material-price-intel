---
phase: 09-smart-accuracy
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - material-price-intel/supabase/functions/process-document/index.ts
  - material-price-intel/supabase/functions/normalize-materials/index.ts
autonomous: true

must_haves:
  truths:
    - "Extraction persists line_type for each line item to the database"
    - "Extraction computes and persists effective_unit_price based on discount attribution"
    - "Per-item discounts reduce the targeted material's effective_unit_price"
    - "Quote-wide discounts are stored at quote level (quote_discount_pct, quote_discount_amount)"
    - "Normalization skips non-material line items (only normalizes line_type='material')"
    - "applies_to_line_item_id is set when a discount targets a specific material line"
  artifacts:
    - path: "material-price-intel/supabase/functions/process-document/index.ts"
      provides: "Updated persistence that saves line_type, computes effective_unit_price, handles discount attribution"
      contains: "line_type"
    - path: "material-price-intel/supabase/functions/normalize-materials/index.ts"
      provides: "Updated normalization that only processes material-type line items"
      contains: "line_type"
  key_links:
    - from: "process-document/index.ts"
      to: "line_items table"
      via: "INSERT with line_type and effective_unit_price columns"
      pattern: "line_type.*effective_unit_price"
    - from: "normalize-materials/index.ts"
      to: "line_items table"
      via: "SELECT filter on line_type = 'material'"
      pattern: "line_type.*material"
---

<objective>
Wire up the extraction persistence to save line item classifications and compute effective prices, and update normalization to only process material-type items.

Purpose: This connects the AI's new classification intelligence (Plan 02) to the database schema (Plan 01). After this plan, newly extracted quotes will have properly classified line items with accurate effective prices, and normalization will correctly skip discounts/fees/notes.

Output: Updated process-document/index.ts with discount attribution and effective price computation, updated normalize-materials/index.ts with line_type filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/supabase/functions/process-document/index.ts
@material-price-intel/supabase/functions/process-document/types.ts
@material-price-intel/supabase/functions/normalize-materials/index.ts

# Prior plan context (needed for new types and schema)
@.planning/phases/09-smart-accuracy/09-01-SUMMARY.md
@.planning/phases/09-smart-accuracy/09-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update process-document persistence to save line_type, compute effective_unit_price, and handle discount attribution</name>
  <files>material-price-intel/supabase/functions/process-document/index.ts</files>
  <action>
Modify the `persistExtraction` function in `index.ts`:

**1. Update the quote INSERT** to include quote-level discount fields:
Add `quote_discount_pct` and `quote_discount_amount` to the quote insert object:
```typescript
quote_discount_pct: extraction.quote_discount_pct,
quote_discount_amount: extraction.quote_discount_amount,
```

**2. Rewrite the line items batch insert** to handle classification and effective pricing.

Replace the existing line item mapping code (the `lineItemRows` construction) with a two-pass approach:

```typescript
// 3. Insert line items with classification and effective pricing
if (extraction.line_items.length > 0) {
  // --- Pass 1: Insert all line items and collect their IDs ---
  const lineItemRows = extraction.line_items.map((item, index) => ({
    quote_id: quoteId,
    raw_description: item.raw_description,
    quantity: item.quantity,
    unit: item.unit,
    unit_price: item.unit_price,
    extended_price: item.extended_price,
    discount_pct: item.discount_pct,
    discount_amount: item.discount_amount,
    line_total: item.line_total,
    notes: item.notes,
    sort_order: index,
    material_id: null,
    line_type: item.line_type ?? 'material',
    effective_unit_price: null as number | null, // computed below
    applies_to_line_item_id: null as string | null, // set in pass 2
  }));

  // --- Compute effective_unit_price for material items ---
  // For each material line, check if any discount line targets it
  for (let i = 0; i < extraction.line_items.length; i++) {
    const item = extraction.line_items[i];
    if (item.line_type !== 'material' || item.unit_price == null) continue;

    let effectivePrice = item.unit_price;

    // Check for per-item discounts on this material
    if (item.discount_pct != null) {
      effectivePrice = item.unit_price * (1 - item.discount_pct / 100);
    } else if (item.discount_amount != null && item.quantity != null && item.quantity > 0) {
      effectivePrice = item.unit_price - (item.discount_amount / item.quantity);
    }

    // Check for discount lines that target this material
    for (const discountItem of extraction.line_items) {
      if (discountItem.line_type !== 'discount') continue;
      if (discountItem.discount_applies_to !== i) continue;

      // This discount line targets material at index i
      if (discountItem.discount_pct != null) {
        effectivePrice = effectivePrice * (1 - discountItem.discount_pct / 100);
      } else if (discountItem.discount_amount != null && item.quantity != null && item.quantity > 0) {
        // Discount amount spread over the material's quantity
        effectivePrice = effectivePrice - (Math.abs(discountItem.discount_amount) / item.quantity);
      } else if (discountItem.line_total != null && discountItem.line_total < 0 && item.quantity != null && item.quantity > 0) {
        // Use negative line_total as discount amount
        effectivePrice = effectivePrice - (Math.abs(discountItem.line_total) / item.quantity);
      }
    }

    // Apply quote-wide discount if present (proportionally)
    if (extraction.quote_discount_pct != null) {
      effectivePrice = effectivePrice * (1 - extraction.quote_discount_pct / 100);
    }

    // Floor at 0 -- negative effective prices are invalid
    lineItemRows[i].effective_unit_price = Math.max(0, Math.round(effectivePrice * 10000) / 10000);
  }

  // --- Insert line items ---
  const { data: insertedLineItems, error: lineItemsError } = await supabase
    .from("line_items")
    .insert(lineItemRows)
    .select("id, sort_order");

  if (lineItemsError) {
    throw new Error(
      `Failed to insert line items: ${lineItemsError.message}`,
    );
  }

  // --- Pass 2: Set applies_to_line_item_id for discount lines ---
  if (insertedLineItems && insertedLineItems.length > 0) {
    // Build sort_order -> id mapping
    const sortOrderToId = new Map<number, string>();
    for (const row of insertedLineItems) {
      sortOrderToId.set(row.sort_order, row.id);
    }

    for (let i = 0; i < extraction.line_items.length; i++) {
      const item = extraction.line_items[i];
      if (item.line_type !== 'discount' || item.discount_applies_to == null) continue;

      const targetId = sortOrderToId.get(item.discount_applies_to);
      const discountId = sortOrderToId.get(i);
      if (targetId && discountId) {
        await supabase
          .from("line_items")
          .update({ applies_to_line_item_id: targetId })
          .eq("id", discountId);
      }
    }
  }
}
```

**Key design decisions:**
- effective_unit_price is ONLY computed for `line_type='material'` items
- Per-item discounts (from the material's own discount_pct/discount_amount) are applied first
- Targeted discount lines (discount_applies_to pointing to this material) are applied second
- Quote-wide discount percentage is applied last (multiplicative)
- The two-pass approach is needed because applies_to_line_item_id references actual DB row IDs, which only exist after INSERT
- Effective price is rounded to 4 decimal places and floored at 0

Do NOT modify the findOrCreateSupplier function. Do NOT modify the main handler (Deno.serve). Only modify the persistExtraction function.
  </action>
  <verify>
Read index.ts and verify:
- Quote INSERT includes quote_discount_pct and quote_discount_amount
- Line item INSERT includes line_type, effective_unit_price, applies_to_line_item_id
- Effective price computation loop handles: per-item discounts, targeted discount lines, quote-wide discounts
- Pass 2 sets applies_to_line_item_id via UPDATE after INSERT
- `.select("id, sort_order")` is added to the line items INSERT for the ID mapping
  </verify>
  <done>Process-document persists line_type, computes effective_unit_price with full discount attribution chain, and links discount lines to their target materials via applies_to_line_item_id</done>
</task>

<task type="auto">
  <name>Task 2: Update normalize-materials to skip non-material line items</name>
  <files>material-price-intel/supabase/functions/normalize-materials/index.ts</files>
  <action>
Modify the normalize-materials Edge Function to only process line items where `line_type = 'material'`.

**Change the line items query** (section 4, "Fetch unnormalized line items"):

Current query:
```typescript
const { data: lineItems, error: lineItemsError } = await supabase
  .from("line_items")
  .select("id, raw_description")
  .eq("quote_id", quoteId)
  .is("material_id", null);
```

Updated query -- add line_type filter:
```typescript
const { data: lineItems, error: lineItemsError } = await supabase
  .from("line_items")
  .select("id, raw_description, line_type")
  .eq("quote_id", quoteId)
  .eq("line_type", "material")
  .is("material_id", null);
```

This is a one-line addition (`.eq("line_type", "material")`). The rest of the function remains identical.

The effect: discount, fee, subtotal_line, and note items are never sent to the AI classifier or linked to canonical materials. Only actual material items get normalized.

Also update the log message in section 5 to be more descriptive:
```typescript
console.log(
  `Normalizing ${lineItems.length} material line items for quote ${quoteId} (non-material items skipped)`,
);
```
  </action>
  <verify>
Read normalize-materials/index.ts and verify:
- Line items query includes `.eq("line_type", "material")` filter
- The select includes "line_type" field
- Log message mentions non-material items being skipped
- No other changes to the function
  </verify>
  <done>Normalization only processes line_type='material' items; discounts, fees, subtotals, and notes are skipped</done>
</task>

</tasks>

<verification>
- process-document saves line_type, effective_unit_price, and applies_to_line_item_id for every line item
- effective_unit_price correctly reflects per-item discounts + targeted discount lines + quote-wide discounts
- normalize-materials only classifies material-type items
- No regressions in existing extraction/normalization flow
</verification>

<success_criteria>
1. New quotes have line_type set on every line item
2. Material items have effective_unit_price computed from all applicable discounts
3. Discount lines are linked to target materials via applies_to_line_item_id
4. Quote-level discounts stored in quotes table
5. Normalization skips non-material items
</success_criteria>

<output>
After completion, create `.planning/phases/09-smart-accuracy/09-03-SUMMARY.md`
</output>
