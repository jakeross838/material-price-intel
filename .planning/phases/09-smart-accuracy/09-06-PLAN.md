---
phase: 09-smart-accuracy
plan: 06
type: execute
wave: 3
depends_on: ["09-01", "09-05"]
files_modified:
  - material-price-intel/src/pages/SearchPage.tsx
  - material-price-intel/src/hooks/useReportsData.ts
  - material-price-intel/src/pages/ReportsPage.tsx
autonomous: true

must_haves:
  truths:
    - "Search page uses effective_unit_price for price comparisons instead of raw unit_price"
    - "Search page only shows material-type line items (not discounts, fees, subtotals, notes)"
    - "Reports use effective_unit_price for price trends and comparisons"
    - "Price stats (min, max, avg) are computed from effective_unit_price"
    - "Both raw and effective prices are visible where they differ"
  artifacts:
    - path: "material-price-intel/src/pages/SearchPage.tsx"
      provides: "Search page filtered to materials only, using effective_unit_price for comparisons"
      contains: "effective_unit_price"
    - path: "material-price-intel/src/hooks/useReportsData.ts"
      provides: "Reports data hook fetching effective_unit_price"
      contains: "effective_unit_price"
    - path: "material-price-intel/src/pages/ReportsPage.tsx"
      provides: "Reports page stat cards using effective prices"
      contains: "effectivePrice"
  key_links:
    - from: "SearchPage.tsx"
      to: "line_items table"
      via: "select includes effective_unit_price, filtered by line_type"
      pattern: "effective_unit_price.*line_type"
    - from: "useReportsData.ts"
      to: "line_items table"
      via: "select includes effective_unit_price"
      pattern: "effective_unit_price"
---

<objective>
Update Search and Reports pages to use effective_unit_price for accurate price comparisons and filter out non-material line items.

Purpose: The core value of this app is accurate cross-supplier price comparison. After Phase 9's classification work, we must ensure comparisons use effective (post-discount) prices and exclude non-material items. This prevents discounts from polluting the price database and ensures users see what they actually paid.

Output: Updated SearchPage, ReportsPage, and useReportsData with effective_unit_price support and material-only filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/src/pages/SearchPage.tsx
@material-price-intel/src/hooks/useReportsData.ts
@material-price-intel/src/pages/ReportsPage.tsx

# Prior plan context
@.planning/phases/09-smart-accuracy/09-01-SUMMARY.md
@.planning/phases/09-smart-accuracy/09-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update SearchPage to filter by material type and show effective prices</name>
  <files>material-price-intel/src/pages/SearchPage.tsx</files>
  <action>
**1. Update the PriceResult type** to include new fields:
```typescript
type PriceResult = {
  line_item_id: string;
  raw_description: string;
  quantity: number | null;
  unit: string | null;
  unit_price: number | null;
  effective_unit_price: number | null;    // NEW
  line_total: number | null;
  line_type: string;                       // NEW
  quote_id: string;
  quote_number: string | null;
  quote_date: string | null;
  project_name: string | null;
  supplier_name: string;
  material_id: string | null;
  canonical_name: string | null;
  category_id: string | null;
};
```

**2. Update the usePriceData query** to fetch new fields and filter by material type:

Change the select to include `effective_unit_price` and `line_type`:
```typescript
.select(
  "id, raw_description, quantity, unit, unit_price, effective_unit_price, line_total, line_type, material_id, quotes(id, quote_number, quote_date, project_name, is_verified, suppliers(name)), materials(canonical_name, category_id)"
)
.eq("line_type", "material")  // Only show material items in search
```

Add the new fields to the flattened result:
```typescript
effective_unit_price: item.effective_unit_price as number | null,
line_type: (item.line_type as string) ?? "material",
```

**3. Update price stats calculation** to use effective_unit_price (falling back to unit_price):

```typescript
const priceStats = useMemo(() => {
  const prices = filtered
    .filter((i) => (i.effective_unit_price ?? i.unit_price) != null)
    .map((i) => (i.effective_unit_price ?? i.unit_price)!);
  if (prices.length === 0) return null;
  const min = Math.min(...prices);
  const max = Math.max(...prices);
  const avg = prices.reduce((s, p) => s + p, 0) / prices.length;
  return { min, max, avg, count: prices.length };
}, [filtered]);
```

**4. Update sorting** to use effective_unit_price:

```typescript
case "price_asc":
  return arr.sort((a, b) =>
    (a.effective_unit_price ?? a.unit_price ?? 0) - (b.effective_unit_price ?? b.unit_price ?? 0)
  );
case "price_desc":
  return arr.sort((a, b) =>
    (b.effective_unit_price ?? b.unit_price ?? 0) - (a.effective_unit_price ?? a.unit_price ?? 0)
  );
```

**5. Update the results table** to show both prices when they differ:

Change the "Unit Price" header to just "Price" and add an "Eff. Price" column:

Actually, simpler approach -- show the effective price as the PRIMARY price column (since that's what matters for comparison), and show the raw price in a smaller secondary column only when different:

Update the "Unit Price" column cell:
```tsx
<td className="px-4 py-2 text-right tabular-nums font-medium">
  {formatCurrency(item.effective_unit_price ?? item.unit_price)}
  {item.effective_unit_price != null && item.unit_price != null && item.effective_unit_price !== item.unit_price && (
    <div className="text-xs text-muted-foreground line-through">
      {formatCurrency(item.unit_price)}
    </div>
  )}
</td>
```

Update the header to clarify:
```tsx
<th className="text-right px-4 py-2 font-medium">Unit Price</th>
```
(Keep the same header text -- the struck-through original price below is self-explanatory.)
  </action>
  <verify>
Read SearchPage.tsx and verify:
- PriceResult includes effective_unit_price and line_type
- Query filters by line_type = 'material'
- Query selects effective_unit_price
- Price stats use effective_unit_price ?? unit_price
- Sorting uses effective_unit_price ?? unit_price
- Table shows effective price as primary, raw price struck-through when different
  </verify>
  <done>Search page shows only material items, uses effective prices for stats/sorting, and displays both raw and effective prices when they differ</done>
</task>

<task type="auto">
  <name>Task 2: Update Reports hooks and page to use effective prices</name>
  <files>
    material-price-intel/src/hooks/useReportsData.ts
    material-price-intel/src/pages/ReportsPage.tsx
  </files>
  <action>
**1. Update useReportsData.ts:**

a) Add `effectiveUnitPrice` to the ReportDataPoint type:
```typescript
export type ReportDataPoint = {
  lineItemId: string;
  rawDescription: string;
  quantity: number | null;
  unit: string | null;
  unitPrice: number;
  effectiveUnitPrice: number;    // NEW - post-discount price (used for charts)
  lineTotal: number | null;
  quoteId: string;
  quoteDate: string | null;
  quoteNumber: string | null;
  projectName: string | null;
  supplierId: string;
  supplierName: string;
  materialId: string;
  canonicalName: string;
  categoryId: string | null;
};
```

b) Update the select query to include `effective_unit_price` and `line_type`:
```typescript
.select(
  "id, raw_description, quantity, unit, unit_price, effective_unit_price, line_total, line_type, material_id, quotes(id, quote_date, quote_number, project_name, supplier_id, is_verified, suppliers(id, name)), materials(id, canonical_name, category_id)"
)
.eq("line_type", "material")  // Only material items in reports
.not("material_id", "is", null)
.not("unit_price", "is", null)
```

c) Update the flattened mapping to include effectiveUnitPrice:
```typescript
effectiveUnitPrice: (item.effective_unit_price as number) ?? (item.unit_price as number),
```

**2. Update ReportsPage.tsx:**

a) In all places where `unitPrice` is used for chart data, use `effectiveUnitPrice` instead.

Search for all occurrences of `.unitPrice` in the file and replace with `.effectiveUnitPrice` for the data passed to charts. This ensures price trend charts show what the user actually paid, not the pre-discount price.

Common patterns to update:
- Where chart data points are constructed (y-axis values)
- Where stat cards compute average, min, max prices
- Where supplier comparison values are calculated

b) Keep `unitPrice` available in the type for showing raw price in tooltips if desired, but use `effectiveUnitPrice` for all computed metrics and chart rendering.

The key locations to update are typically in `useMemo` hooks that compute:
- Chart data arrays (use effectiveUnitPrice for y values)
- Stat card calculations (avgPrice, minPrice, maxPrice)
- Supplier comparison aggregates

Since the ReportsPage likely references `d.unitPrice` in multiple computed values, do a targeted replacement. Typical pattern:
```typescript
// Before:
const avgPrice = data.reduce((s, d) => s + d.unitPrice, 0) / data.length;
// After:
const avgPrice = data.reduce((s, d) => s + d.effectiveUnitPrice, 0) / data.length;
```
  </action>
  <verify>
Read useReportsData.ts and verify:
- ReportDataPoint includes effectiveUnitPrice field
- Query filters by line_type = 'material'
- Query selects effective_unit_price
- Mapping uses effective_unit_price ?? unit_price for effectiveUnitPrice

Read ReportsPage.tsx and verify:
- Chart data uses effectiveUnitPrice for y-axis values
- Stat cards use effectiveUnitPrice for averages, min, max
- No references to unitPrice for computed metrics (only effectiveUnitPrice)
  </verify>
  <done>Reports use effective_unit_price for all price trends, comparisons, and statistics. Only material-type items appear in reports.</done>
</task>

</tasks>

<verification>
- Search page shows only material items
- Search price stats use effective prices
- Reports charts use effective prices
- Reports stat cards use effective prices
- Both pages filter out non-material items
- Raw price shown struck-through when discount exists (search only)
</verification>

<success_criteria>
1. Search page filters to material-only items via line_type='material'
2. Search price stats (min, max, avg) use effective_unit_price
3. Search results show effective price primary, raw price struck-through when different
4. Reports data hook fetches effective_unit_price and filters by material type
5. Reports charts render effective prices, not raw prices
6. Reports stat cards compute from effective prices
</success_criteria>

<output>
After completion, create `.planning/phases/09-smart-accuracy/09-06-SUMMARY.md`
</output>
