---
phase: 09-smart-accuracy
plan: 05
type: execute
wave: 3
depends_on: ["09-01", "09-03"]
files_modified:
  - material-price-intel/src/components/review/LineItemsEditor.tsx
  - material-price-intel/src/components/review/ReviewForm.tsx
  - material-price-intel/src/pages/QuoteDetailPage.tsx
  - material-price-intel/src/hooks/useQuoteReview.ts
autonomous: true

must_haves:
  truths:
    - "Review UI shows a line_type badge/indicator on each line item"
    - "Review UI allows users to change a line item's type via dropdown"
    - "Approved quote view shows line_type badges with color coding"
    - "Non-material items are visually distinct from material items"
    - "Effective unit price is shown alongside raw unit price where different"
    - "useQuoteReview passes line_type in the save payload"
  artifacts:
    - path: "material-price-intel/src/components/review/LineItemsEditor.tsx"
      provides: "Line item editor with line_type dropdown column and effective price display"
      contains: "line_type"
    - path: "material-price-intel/src/components/review/ReviewForm.tsx"
      provides: "Review form that passes line_type through to save"
      contains: "line_type"
    - path: "material-price-intel/src/pages/QuoteDetailPage.tsx"
      provides: "Approved view with line type badges and effective price column"
      contains: "line_type"
    - path: "material-price-intel/src/hooks/useQuoteReview.ts"
      provides: "Updated review hook with line_type in payload"
      contains: "line_type"
  key_links:
    - from: "LineItemsEditor.tsx"
      to: "ReviewForm.tsx"
      via: "EditableLineItem type with line_type field"
      pattern: "line_type.*LineItemType"
    - from: "ReviewForm.tsx"
      to: "useQuoteReview.ts"
      via: "gatherFormData includes line_type"
      pattern: "line_type.*item\\.line_type"
    - from: "QuoteDetailPage.tsx"
      to: "line_items query"
      via: "select includes line_type, effective_unit_price"
      pattern: "line_type.*effective_unit_price"
---

<objective>
Add line item classification display and reclassification controls to the Review UI and approved quote view.

Purpose: Phase 9 requirement #6: "Review UI shows line item classifications and lets users reclassify if AI got it wrong." Users need to see what type each line is (material, discount, fee, etc.), be able to change it during review, and see effective prices on approved quotes.

Output: Updated LineItemsEditor with type dropdown, updated QuoteDetailPage with type badges and effective prices.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/src/components/review/LineItemsEditor.tsx
@material-price-intel/src/components/review/ReviewForm.tsx
@material-price-intel/src/pages/QuoteDetailPage.tsx
@material-price-intel/src/hooks/useQuoteReview.ts
@material-price-intel/src/lib/types.ts

# Prior plan context
@.planning/phases/09-smart-accuracy/09-01-SUMMARY.md
@.planning/phases/09-smart-accuracy/09-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add line_type dropdown and effective price to LineItemsEditor and wire through ReviewForm</name>
  <files>
    material-price-intel/src/components/review/LineItemsEditor.tsx
    material-price-intel/src/components/review/ReviewForm.tsx
    material-price-intel/src/hooks/useQuoteReview.ts
  </files>
  <action>
**1. Update LineItemsEditor.tsx:**

a) Add `line_type` to the `EditableLineItem` type:
```typescript
import type { LineItemType } from "@/lib/types";

export type EditableLineItem = {
  id: string;
  raw_description: string;
  quantity: number | null;
  unit: string | null;
  unit_price: number | null;
  line_total: number | null;
  notes: string | null;
  confidence?: number;
  line_type: LineItemType;                // NEW
  effective_unit_price: number | null;    // NEW (read-only display)
};
```

b) Add a `line_type` dropdown column to the table header (between "#" and "Description"):
```tsx
<th className="px-2 py-2 text-left font-medium w-28">Type</th>
```

c) Add the type dropdown cell in each row (between row number and description):
```tsx
<td className="px-2 py-1.5">
  <select
    value={item.line_type}
    onChange={(e) =>
      handleFieldChange(i, "line_type", e.target.value)
    }
    className={cn(
      "h-8 w-full rounded-md border border-input bg-transparent px-1.5 text-xs",
      item.line_type === 'discount' && "text-orange-600 bg-orange-50",
      item.line_type === 'fee' && "text-purple-600 bg-purple-50",
      item.line_type === 'subtotal_line' && "text-gray-500 bg-gray-50",
      item.line_type === 'note' && "text-gray-400 bg-gray-50 italic",
    )}
  >
    <option value="material">Material</option>
    <option value="discount">Discount</option>
    <option value="fee">Fee</option>
    <option value="subtotal_line">Subtotal</option>
    <option value="note">Note</option>
  </select>
</td>
```

d) Color-code the row background based on line_type (update the existing `cn` on the `<tr>`):
```tsx
className={cn(
  "border-b last:border-0",
  lowConfidence && "bg-amber-50",
  item.line_type === 'discount' && !lowConfidence && "bg-orange-50/50",
  item.line_type === 'fee' && !lowConfidence && "bg-purple-50/50",
  item.line_type === 'subtotal_line' && !lowConfidence && "bg-gray-50/50",
  item.line_type === 'note' && !lowConfidence && "bg-gray-50/50 opacity-60",
)}
```

e) Update the `handleAddRow` function to set default `line_type`:
```typescript
const newItem: EditableLineItem = {
  // ... existing fields ...
  line_type: 'material',
  effective_unit_price: null,
};
```

f) Update `handleFieldChange` to include `line_type` in the non-numeric fields (it's already a string field, so no special handling needed beyond ensuring it's NOT in `numericFields`).

**2. Update ReviewForm.tsx:**

Update `gatherFormData()` to include `line_type` in the line items payload:
```typescript
line_items: lineItems.map((item) => ({
  raw_description: item.raw_description,
  quantity: item.quantity,
  unit: item.unit,
  unit_price: item.unit_price,
  extended_price: null,
  discount_pct: null,
  discount_amount: null,
  line_total: item.line_total,
  notes: item.notes,
  line_type: item.line_type,                  // NEW
  effective_unit_price: item.effective_unit_price,  // NEW
})),
```

**3. Update useQuoteReview.ts:**

Update the `QuoteReviewUpdate.line_items` array type to include new fields:
```typescript
line_items?: Array<{
  raw_description: string;
  quantity: number | null;
  unit: string | null;
  unit_price: number | null;
  extended_price: number | null;
  discount_pct: number | null;
  discount_amount: number | null;
  line_total: number | null;
  notes: string | null;
  line_type: string;                      // NEW
  effective_unit_price: number | null;    // NEW
}>;
```

Import LineItemType if desired, or use `string` since it's serialized to JSON for the RPC call.
  </action>
  <verify>
Read all three files and verify:
- LineItemsEditor has line_type dropdown column with 5 options and color coding
- EditableLineItem type includes line_type and effective_unit_price
- ReviewForm gatherFormData includes line_type and effective_unit_price
- useQuoteReview QuoteReviewUpdate type includes line_type and effective_unit_price in line_items array
- Row background colors differ by line_type
- New rows default to line_type='material'
  </verify>
  <done>Review mode shows line_type dropdown per item with color coding, saves line_type through to the database</done>
</task>

<task type="auto">
  <name>Task 2: Update QuoteDetailPage approved view with line type badges and effective price column</name>
  <files>material-price-intel/src/pages/QuoteDetailPage.tsx</files>
  <action>
**1. Update the line items query** (in the `useQuery` for line_items) to include new fields:

Currently selects `"*"` which will automatically include new columns. No query change needed. But update the initialization of `editableLineItems` to map the new fields:

```typescript
setEditableLineItems(
  lineItems.map((item, index) => ({
    id: item.id,
    raw_description: item.raw_description,
    quantity: item.quantity,
    unit: item.unit,
    unit_price: item.unit_price,
    line_total: item.line_total,
    notes: item.notes,
    confidence: extractedLineItems[index]?.confidence,
    line_type: item.line_type ?? 'material',           // NEW
    effective_unit_price: item.effective_unit_price,    // NEW
  }))
);
```

**2. Add a helper function** for line type badge rendering:

```typescript
function LineTypeBadge({ type }: { type: string }) {
  const config: Record<string, { label: string; className: string }> = {
    material: { label: "Material", className: "bg-blue-50 text-blue-700" },
    discount: { label: "Discount", className: "bg-orange-50 text-orange-700" },
    fee: { label: "Fee", className: "bg-purple-50 text-purple-700" },
    subtotal_line: { label: "Subtotal", className: "bg-gray-100 text-gray-600" },
    note: { label: "Note", className: "bg-gray-100 text-gray-500 italic" },
  };
  const c = config[type] ?? config.material;
  return (
    <span className={cn("inline-flex items-center rounded-full px-2 py-0.5 text-xs font-medium", c.className)}>
      {c.label}
    </span>
  );
}
```

**3. Update the approved view line items table:**

Add a "Type" column header after "#":
```tsx
<th className="text-left px-4 py-2 font-medium">Type</th>
```

Add an "Effective Price" column header after "Unit Price":
```tsx
<th className="text-right px-4 py-2 font-medium">Eff. Price</th>
```

In each row, add the type badge cell after the row number:
```tsx
<td className="px-4 py-2">
  <LineTypeBadge type={item.line_type} />
</td>
```

Add effective price cell after unit price:
```tsx
<td className="px-4 py-2 text-right tabular-nums">
  {item.effective_unit_price != null && item.effective_unit_price !== item.unit_price
    ? formatCurrency(item.effective_unit_price)
    : <span className="text-muted-foreground">{"\u2014"}</span>
  }
</td>
```

**4. Gray out non-material rows** in the approved view:
```tsx
<tr
  key={item.id}
  className={cn(
    "border-b last:border-0 hover:bg-muted/30",
    item.line_type !== 'material' && "opacity-60",
  )}
>
```

**5. Import the cn utility** if not already imported (it already is in this file).

**6. Import LineItemType** from types if needed for type safety on the badge component.
  </action>
  <verify>
Read QuoteDetailPage.tsx and verify:
- Approved view line items table has "Type" column with LineTypeBadge
- Approved view has "Eff. Price" column showing effective_unit_price when different from unit_price
- Non-material rows are visually dimmed (opacity-60)
- editableLineItems initialization includes line_type and effective_unit_price
- LineTypeBadge helper function exists with 5 type configs
  </verify>
  <done>Approved quote view shows line type badges (color-coded), effective price column, and dims non-material items. Review mode properly initializes line_type from stored data.</done>
</task>

</tasks>

<verification>
- Review mode: line_type dropdown visible on each row with 5 options
- Review mode: row colors change based on line_type selection
- Review mode: save sends line_type to database via RPC
- Approved view: Type badge column shows colored badges for each type
- Approved view: Effective Price column shows post-discount price when different
- Approved view: non-material rows dimmed
</verification>

<success_criteria>
1. Users can see line_type classification on every line item in both review and approved views
2. Users can reclassify line items via dropdown during review
3. Reclassification is persisted when saving
4. Effective unit price displayed when different from raw unit price
5. Visual distinction between material and non-material items
</success_criteria>

<output>
After completion, create `.planning/phases/09-smart-accuracy/09-05-SUMMARY.md`
</output>
