---
phase: 09-smart-accuracy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/functions/process-document/types.ts
  - material-price-intel/supabase/functions/process-document/prompt.ts
  - material-price-intel/supabase/functions/process-document/validation.ts
autonomous: true

must_haves:
  truths:
    - "AI extraction returns a line_type field for each line item"
    - "AI extraction returns discount_applies_to indicating which material a discount targets"
    - "Validation catches impossible prices: $0.00 unit_price on material, negative quantities without credit context"
    - "Validation flags call-for-pricing items"
    - "Validation warns about non-material items that look like they should be material or vice versa"
  artifacts:
    - path: "material-price-intel/supabase/functions/process-document/types.ts"
      provides: "ExtractedLineItem with line_type and discount_applies_to fields"
      contains: "line_type"
    - path: "material-price-intel/supabase/functions/process-document/prompt.ts"
      provides: "Updated system prompt teaching Claude to classify line item types and attribute discounts"
      contains: "line_type"
    - path: "material-price-intel/supabase/functions/process-document/validation.ts"
      provides: "Enhanced validation with impossible price detection and line type validation"
      contains: "impossible"
  key_links:
    - from: "prompt.ts"
      to: "types.ts"
      via: "JSON schema in prompt matches ExtractedLineItem type"
      pattern: "line_type.*material.*discount.*fee"
    - from: "validation.ts"
      to: "types.ts"
      via: "import ExtractionResult"
      pattern: "import.*ExtractionResult.*from.*types"
---

<objective>
Teach the AI extraction engine to classify line item types and attribute discounts, and enhance validation to catch impossible prices.

Purpose: This is the core intelligence upgrade. Currently the AI extracts every line as a generic item. After this plan, it will distinguish materials from discounts, fees, subtotals, and notes. It will also attribute discount lines to specific materials (like the Advantage Lumber discount case). Enhanced validation catches data quality issues before they pollute the price database.

Output: Updated extraction types, prompt, and validation logic in the process-document Edge Function.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/supabase/functions/process-document/types.ts
@material-price-intel/supabase/functions/process-document/prompt.ts
@material-price-intel/supabase/functions/process-document/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update extraction types to include line_type and discount attribution</name>
  <files>material-price-intel/supabase/functions/process-document/types.ts</files>
  <action>
Update `types.ts` in the process-document function:

1. **Add LineItemType type** at the top of the file (after the header comment):
   ```typescript
   export type LineItemType = 'material' | 'discount' | 'fee' | 'subtotal_line' | 'note';
   ```

2. **Add fields to ExtractedLineItem:**
   ```typescript
   export type ExtractedLineItem = {
     raw_description: string;
     line_type: LineItemType;                // NEW - what kind of line this is
     quantity: number | null;
     unit: string | null;
     unit_price: number | null;
     extended_price: number | null;
     discount_pct: number | null;
     discount_amount: number | null;
     line_total: number | null;
     notes: string | null;
     confidence: number;
     discount_applies_to: number | null;     // NEW - 0-based index of the material line this discount targets (null = quote-wide)
     is_credit: boolean;                     // NEW - true for return/credit lines (negative amounts)
     pricing_flag: string | null;            // NEW - 'call_for_pricing' | 'zero_price' | 'negative_quantity' | null
   };
   ```

3. **Add quote-level discount fields to ExtractionResult:**
   ```typescript
   export type ExtractionResult = {
     // ... all existing fields ...
     quote_discount_pct: number | null;     // NEW - quote-wide discount percentage
     quote_discount_amount: number | null;  // NEW - quote-wide discount dollar amount
     // ... overall_confidence, extraction_notes unchanged
   };
   ```

Preserve all existing fields and their comments. Only ADD new fields.
  </action>
  <verify>Read types.ts and confirm: LineItemType exported, ExtractedLineItem has line_type + discount_applies_to + is_credit + pricing_flag, ExtractionResult has quote_discount_pct + quote_discount_amount</verify>
  <done>Extraction types include all new classification and discount attribution fields</done>
</task>

<task type="auto">
  <name>Task 2: Update extraction prompt with line item classification and discount attribution rules</name>
  <files>material-price-intel/supabase/functions/process-document/prompt.ts</files>
  <action>
Update the SYSTEM_PROMPT in `prompt.ts` to teach Claude about line item classification.

**Changes to the JSON schema section:**
Add these new fields to the line_items object in the schema:
```json
"line_type": "string: 'material' | 'discount' | 'fee' | 'subtotal_line' | 'note'",
"discount_applies_to": "number or null (0-based index of the material line item this discount applies to)",
"is_credit": "boolean (true for return/credit lines with negative amounts)",
"pricing_flag": "string or null ('call_for_pricing' | 'zero_price' | 'negative_quantity' | null)"
```

Also add to the top-level object:
```json
"quote_discount_pct": "number or null (quote-wide discount percentage)",
"quote_discount_amount": "number or null (quote-wide discount dollar amount)"
```

**Add a new section "## Line Item Classification Rules" BEFORE "## Extraction Rules":**

```
## Line Item Classification Rules

Classify each line item with a line_type:

**material**: A physical product being purchased. Has quantity, unit, and unit_price. This is the most common type.
- Examples: "Ipe 5/4x6x16", "2x4x8 PT Pine #2", "GRK RSS Screws 5/16x3-1/8"

**discount**: A price reduction applied to one or more materials. Usually has a negative line_total or a discount_pct. Does NOT have a meaningful unit_price of its own.
- Examples: "Discount", "10% Volume Discount", "Customer Loyalty Credit", "Price Adjustment"
- If the discount appears directly below a specific material line and seems to apply only to that material, set discount_applies_to to that material's 0-based index.
- If the discount is quote-wide (e.g., "Total Quote Discount 5%"), set discount_applies_to to null and capture it in the top-level quote_discount_pct/quote_discount_amount.

**fee**: A surcharge or additional cost that is NOT a physical material. Has a positive amount.
- Examples: "Minimum Order Surcharge", "Fuel Surcharge", "Rush Order Fee", "Handling Fee", "Restocking Fee"
- EXCEPTION: Delivery/freight charges should STILL go in totals.delivery_cost per existing Rule 8. Only use fee for surcharges that are NOT delivery.

**subtotal_line**: A subtotal, section total, or running total that summarizes other lines. Should NOT be double-counted in the totals.
- Examples: "Subtotal", "Section Total", "Material Total", "Lumber Subtotal"

**note**: Informational text that is not a priced item. No pricing data.
- Examples: "Prices valid for 30 days", "Subject to availability", "All lumber is rough sawn unless noted"

## Discount Attribution Rules

When you encounter a discount line:

1. **Per-item discount**: If a discount clearly applies to the IMMEDIATELY PRECEDING material line (e.g., indented beneath it, or says "Discount on Ipe 5/4x6x16"), set discount_applies_to to that material's 0-based line index.

2. **Multi-item discount**: If a discount applies to a section of items but you cannot attribute it to a single item, set discount_applies_to to null and add a note explaining which items it covers.

3. **Quote-wide discount**: If the discount applies to the entire quote (e.g., "5% contractor discount"), set discount_applies_to to null AND capture it in the top-level quote_discount_pct and/or quote_discount_amount fields.

4. **Ambiguous discount**: If unclear which item(s) a discount applies to, set discount_applies_to to null and reduce that line's confidence to 0.5 or lower.

## Edge Case Handling

- **"Call for Pricing" items**: Set unit_price to null, pricing_flag to "call_for_pricing". Do NOT guess a price.
- **$0.00 unit price on a material line**: Set pricing_flag to "zero_price". This usually means pricing was omitted or the item is included free.
- **Negative quantities without a return/credit context**: Set pricing_flag to "negative_quantity". Mark is_credit as false (this is suspicious and needs review).
- **Credit/return lines**: Set is_credit to true. These have negative line_total values.
- **Minimum order charges**: Classify as line_type "fee".
- **Bundle pricing** (e.g., "10 pcs @ $5.00/pc"): Classify as line_type "material" with quantity=10, unit_price=5.00.
- **Volume tier pricing** (e.g., "1-99: $10/ea, 100+: $8/ea"): Use the tier that matches the quoted quantity. Add a note about the tier structure.
```

**Update existing Rule 7** (about discounts) to:
"7. If a discount is applied to a line, capture both the percentage and dollar amount if available. Also classify the discount as a separate line_type='discount' entry if it appears as its own line on the quote. Do NOT merge discount lines into the material line they modify -- keep them as separate line items with discount_applies_to set correctly."

**Add new Rule 11:**
"11. For every line item, you MUST set the line_type field. When in doubt, classify as 'material' and reduce confidence."

**Add new Rule 12:**
"12. Credit/return lines with negative amounts: set is_credit=true. These are legitimate and should be preserved, not treated as errors."
  </action>
  <verify>
Read prompt.ts and perform these specific checks:

1. **JSON schema fields present** -- search for these exact strings in the schema object:
   - `"line_type"` with value mentioning all 5 types (material, discount, fee, subtotal_line, note)
   - `"discount_applies_to"` with value mentioning 0-based index
   - `"is_credit"` with value mentioning boolean
   - `"pricing_flag"` with value mentioning call_for_pricing, zero_price, negative_quantity
   - `"quote_discount_pct"` at top level
   - `"quote_discount_amount"` at top level

2. **Classification rules section** -- verify the heading "## Line Item Classification Rules" exists AND each of these type definitions is present with examples:
   - `**material**:` followed by product examples (Ipe, 2x4, screws)
   - `**discount**:` followed by discount examples
   - `**fee**:` followed by surcharge examples, with the delivery exception note
   - `**subtotal_line**:` followed by subtotal examples
   - `**note**:` followed by informational text examples

3. **Discount Attribution Rules section** -- verify heading exists AND all 4 numbered scenarios present:
   - "1. **Per-item discount**"
   - "2. **Multi-item discount**"
   - "3. **Quote-wide discount**"
   - "4. **Ambiguous discount**"

4. **Edge Case Handling section** -- verify heading exists AND all 7 cases present:
   - "Call for Pricing"
   - "$0.00 unit price"
   - "Negative quantities"
   - "Credit/return lines"
   - "Minimum order charges"
   - "Bundle pricing"
   - "Volume tier pricing"

5. **Updated rules** -- verify Rule 7 mentions line_type='discount', Rule 11 about mandatory line_type, Rule 12 about is_credit
  </verify>
  <done>Extraction prompt teaches Claude to classify line items into 5 types, attribute discounts, and handle edge cases including call-for-pricing, zero prices, credits, and bundle pricing</done>
</task>

<task type="auto">
  <name>Task 3: Enhance validation with impossible price detection and line type consistency checks</name>
  <files>material-price-intel/supabase/functions/process-document/validation.ts</files>
  <action>
Add new validation checks to `validation.ts` AFTER the existing checks (before the confidence adjustment section). Keep all existing validation code unchanged.

**Add new section: "5. Line type consistency checks"**

```typescript
// -------------------------------------------------
// 5. Line type consistency checks
// -------------------------------------------------
for (let i = 0; i < extraction.line_items.length; i++) {
  const item = extraction.line_items[i];

  // 5a. Material items should have unit_price
  if (item.line_type === 'material' && item.unit_price == null && item.pricing_flag !== 'call_for_pricing') {
    warnings.push({
      field: `line_items[${i}].unit_price`,
      expected: -1, // sentinel: not a numeric comparison
      actual: 0,
      message: `Material line item "${item.raw_description}" has no unit_price and is not flagged as call-for-pricing`,
    });
  }

  // 5b. Impossible: $0.00 unit_price on a material (unless flagged)
  if (item.line_type === 'material' && item.unit_price === 0 && item.pricing_flag !== 'zero_price') {
    warnings.push({
      field: `line_items[${i}].unit_price`,
      expected: -1,
      actual: 0,
      message: `Material "${item.raw_description}" has $0.00 unit price but is not flagged as zero_price`,
    });
  }

  // 5c. Discount lines should have negative line_total or discount info
  if (item.line_type === 'discount') {
    const hasDiscountData = (item.discount_pct != null) || (item.discount_amount != null) || (item.line_total != null && item.line_total < 0);
    if (!hasDiscountData) {
      warnings.push({
        field: `line_items[${i}].line_type`,
        expected: -1,
        actual: 0,
        message: `Line item classified as "discount" but has no discount_pct, discount_amount, or negative line_total: "${item.raw_description}"`,
      });
    }
  }

  // 5d. Negative quantity without credit context
  if (item.quantity != null && item.quantity < 0 && !item.is_credit) {
    warnings.push({
      field: `line_items[${i}].quantity`,
      expected: 0,
      actual: item.quantity,
      message: `Negative quantity (${item.quantity}) on non-credit line "${item.raw_description}" -- may need review`,
    });
  }

  // 5e. Subtotal lines should not be counted in totals
  // (This is informational -- the persistence layer handles exclusion)
  if (item.line_type === 'subtotal_line' && item.line_total != null) {
    // No warning needed, but we track it for subtotal calculation adjustments
  }
}
```

**Add new section: "6. Subtotal recalculation excluding non-material items"**

Update the subtotal check (section 2) logic. Instead of modifying the existing check, add a supplementary check:

```typescript
// -------------------------------------------------
// 6. Adjusted subtotal check (excluding non-material items)
// -------------------------------------------------
// If the basic subtotal check (section 2) produced a warning,
// try recalculating excluding subtotal_line items which shouldn't be double-counted
const materialAndFeeLineTotals = extraction.line_items
  .filter((item) => item.line_type !== 'subtotal_line' && item.line_type !== 'note')
  .map((item) => item.line_total)
  .filter((t): t is number => t != null);

if (extraction.totals.subtotal != null && materialAndFeeLineTotals.length >= 2) {
  const adjustedSum = materialAndFeeLineTotals.reduce((sum, t) => sum + t, 0);
  // If the adjusted sum is closer to stated subtotal than the raw sum,
  // remove the section-2 warning (it was caused by including subtotal lines)
  if (isClose(adjustedSum, extraction.totals.subtotal, 1.0)) {
    const subtotalWarningIdx = warnings.findIndex(w => w.field === 'totals.subtotal');
    if (subtotalWarningIdx !== -1) {
      warnings.splice(subtotalWarningIdx, 1);
    }
  }
}
```

**Important**: Do NOT modify the existing 4 validation sections (line item math, subtotal, grand total, tax rate). Only ADD sections 5 and 6 after section 4.

Also update the import to use the new type:
```typescript
import type { ExtractionResult } from "./types.ts";
```
This import already exists and will automatically pick up the new fields since ExtractionResult references the updated ExtractedLineItem.
  </action>
  <verify>
Read validation.ts and verify:
- Original 4 sections (line item math, subtotal, grand total, tax rate) are UNCHANGED
- Section 5 exists with checks: 5a (material needs price), 5b (zero price), 5c (discount consistency), 5d (negative quantity)
- Section 6 exists with adjusted subtotal check that excludes subtotal_line items
- No existing code was removed or modified
  </verify>
  <done>Validation catches impossible prices ($0 material, missing material price), discount consistency issues, negative quantities without credit context, and correctly handles subtotal lines in totals calculation</done>
</task>

</tasks>

<verification>
- types.ts has LineItemType and all new ExtractedLineItem/ExtractionResult fields
- prompt.ts has classification rules, discount attribution rules, edge case handling
- validation.ts has sections 5 and 6 with all specified checks
- All existing code in all three files is preserved (additive changes only)
</verification>

<success_criteria>
1. ExtractedLineItem has line_type, discount_applies_to, is_credit, pricing_flag fields
2. System prompt contains classification rules for all 5 line types with examples
3. System prompt contains discount attribution rules for 4 scenarios
4. System prompt contains edge case handling for 6 cases
5. Validation catches: zero price materials, missing prices, discount inconsistency, negative quantities
6. Validation adjusts subtotal check to exclude subtotal_line items
</success_criteria>

<output>
After completion, create `.planning/phases/09-smart-accuracy/09-02-SUMMARY.md`
</output>
