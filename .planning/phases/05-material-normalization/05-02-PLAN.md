---
phase: 05-material-normalization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - material-price-intel/supabase/functions/normalize-materials/index.ts
  - material-price-intel/supabase/functions/normalize-materials/classifier.ts
autonomous: true

must_haves:
  truths:
    - "AI classifies 'Ipe decking 1.25x6x16' into species=Ipe, dimensions=5/4x6x16, category=lumber"
    - "AI classifies '2x4x8 #2 PT' into species=Pine, dimensions=2x4x8, grade=#2, treatment=Pressure Treated"
    - "Fuzzy matching finds existing canonical material when one exists above threshold"
    - "New canonical material created when no match found"
    - "Line items get material_id set after normalization"
    - "Raw description added as alias to matched/created material"
  artifacts:
    - path: "material-price-intel/supabase/functions/normalize-materials/index.ts"
      provides: "Edge Function entry point for normalization"
      contains: "normalize-materials"
    - path: "material-price-intel/supabase/functions/normalize-materials/classifier.ts"
      provides: "AI classification prompt and parsing logic"
      contains: "classifyMaterial"
  key_links:
    - from: "normalize-materials/index.ts"
      to: "classifier.ts"
      via: "import classifyMaterial"
      pattern: "import.*classifyMaterial"
    - from: "normalize-materials/index.ts"
      to: "material_aliases"
      via: "supabase insert"
      pattern: "from.*material_aliases"
    - from: "normalize-materials/index.ts"
      to: "line_items"
      via: "supabase update material_id"
      pattern: "update.*material_id"
    - from: "normalize-materials/index.ts"
      to: "find_similar_material"
      via: "supabase rpc call"
      pattern: "rpc.*find_similar_material"
---

<objective>
Create the `normalize-materials` Edge Function that receives a quote_id, loads its line items, uses Claude Haiku to classify each raw_description into structured material fields, fuzzy-matches against existing canonical materials, and either links to an existing material or creates a new one. Each raw_description is recorded as an alias.

Purpose: This is the core AI engine that makes "Ipe decking 1.25x6x16" and "Ipe 5/4x6x16 S4S" resolve to the same canonical material, enabling cross-supplier price comparison.

Output: Deployed Edge Function that normalizes all line items for an approved quote.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-material-normalization/05-01-SUMMARY.md
@material-price-intel/supabase/functions/process-document/index.ts
@material-price-intel/supabase/functions/process-document/prompt.ts
@material-price-intel/supabase/functions/process-document/types.ts
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/009_material_aliases.sql
@material-price-intel/src/lib/types.ts
</context>

<design_notes>
**Two-tier similarity threshold (conscious design decision):**
The `find_similar_material()` RPC uses a search threshold of 0.3 -- this is intentionally lower to cast a wide net and return potential matches. The Edge Function then applies a stricter auto-link threshold of 0.5 before automatically linking a line item to an existing material. This two-tier approach means:
- 0.3-0.5 similarity: result returned by RPC but NOT auto-linked (available for future manual review)
- 0.5+ similarity: auto-linked confidently
This prevents false positive auto-matches while keeping the fuzzy search useful for near-misses.
The ROADMAP's "similarity threshold >= 0.3" refers to the search/matching threshold, not the auto-link threshold.
</design_notes>

<tasks>

<task type="auto">
  <name>Task 1: Create AI material classifier</name>
  <files>material-price-intel/supabase/functions/normalize-materials/classifier.ts</files>
  <action>
Create `classifier.ts` with a function that takes one or more raw_description strings and returns structured material classifications via Claude Haiku.

**Classification output type:**
```typescript
export type MaterialClassification = {
  raw_description: string;
  species: string | null;       // "Ipe", "Pine", "Cedar", "Oak", etc.
  dimensions: string | null;    // Normalized: "5/4x6x16", "2x4x8" (always nominal)
  grade: string | null;         // "#1", "#2", "Select", "Premium", "Clear"
  treatment: string | null;     // "Pressure Treated", "Kiln Dried", "S4S", null
  unit_of_measure: string;      // "pc", "lf", "bf", "sqft", "ea"
  category: string;             // "lumber", "hardware", "other" etc.
  canonical_name: string;       // AI's best canonical name: "Ipe 5/4x6x16 S4S"
  confidence: number;           // 0.0-1.0
};
```

**Batch classification function:**
```typescript
export async function classifyMaterials(
  descriptions: string[],
  anthropicApiKey: string
): Promise<MaterialClassification[]>
```

This function sends ALL descriptions in a single Claude Haiku call for efficiency. The prompt should:

1. **System prompt** that defines the JSON output schema and lumber dimension normalization rules:
   - Convert decimal dimensions to nominal fractions: 1.25" = 5/4, 1.5" = 2x (nominal), 0.75" = 1x (nominal)
   - Standard nominal lumber: 1x, 2x, 4x, 5/4, 6/4, 8/4
   - Width in nominal inches: 2, 3, 4, 6, 8, 10, 12
   - Length in feet: 8, 10, 12, 14, 16, 18, 20
   - Format: "{thickness}x{width}x{length}" e.g. "5/4x6x16"
   - S4S (Surfaced 4 Sides) goes in treatment, not dimensions
   - Pressure Treated (PT, ACQ, CCA) goes in treatment
   - Kiln Dried (KD, KDAT) goes in treatment
   - Common species abbreviations: "PT Pine" = species "Pine" + treatment "Pressure Treated"
   - canonical_name format: "{Species} {Dimensions}" optionally with grade/treatment if distinctive, e.g. "Ipe 5/4x6x16", "PT Pine 2x4x8 #2"
   - For non-lumber items (screws, fasteners, adhesives, flashing), category = appropriate category, species/dimensions/grade/treatment = null, canonical_name = cleaned description

2. **User message** with the array of descriptions to classify.

3. **Parse response** -- strip markdown fences (same pattern as process-document), parse JSON array.

4. **Error handling** -- if Claude returns fewer results than descriptions, log warning and pad with fallback classifications (category="other", canonical_name=raw_description).

Use model `claude-haiku-4-5-20251001` (same as process-document).
Use `import Anthropic from "npm:@anthropic-ai/sdk@latest"` (Deno import pattern).
  </action>
  <verify>
Run a Deno syntax/type check on the file:
```bash
cd material-price-intel && npx supabase functions serve normalize-materials --no-verify-jwt 2>&1 | head -20
```
If supabase CLI is not available, verify the file has valid TypeScript syntax by running:
```bash
deno check --no-lock supabase/functions/normalize-materials/classifier.ts 2>&1 || echo "If deno not found, verify file exports classifyMaterials and MaterialClassification by reading file content"
```
At minimum, verify the file exists and exports the expected symbols by reading it back and confirming it contains `export async function classifyMaterials` and `export type MaterialClassification`.
  </verify>
  <done>
AI classifier function created that takes raw descriptions and returns structured material classifications with species, dimensions, grade, treatment, category, and canonical_name. Uses Claude Haiku in batch mode. Handles lumber dimension normalization (decimal to nominal fractions).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create normalize-materials Edge Function</name>
  <files>material-price-intel/supabase/functions/normalize-materials/index.ts</files>
  <action>
Create the main Edge Function entry point. Follow the exact same patterns as `process-document/index.ts` (CORS headers, Deno.serve, service role Supabase client, error handling).

**Request:** `{ quote_id: string }`

**Flow:**

1. Parse request body for `quote_id`.

2. Create Supabase client with service role key (same pattern as process-document).

3. Fetch the quote to verify it exists and is_verified = TRUE:
```typescript
const { data: quote, error } = await supabase
  .from("quotes")
  .select("id, organization_id, is_verified")
  .eq("id", quoteId)
  .single();
```
Return 400 if quote not found or not verified.

4. Fetch all line items for this quote where material_id IS NULL:
```typescript
const { data: lineItems } = await supabase
  .from("line_items")
  .select("id, raw_description")
  .eq("quote_id", quoteId)
  .is("material_id", null);
```
If no unnormalized line items, return 200 with `{ success: true, message: "No items to normalize", normalized: 0 }`.

5. Call `classifyMaterials()` with the raw_description array.

6. For each classified line item:

   a. **Fuzzy match** existing materials using the RPC:
   ```typescript
   const { data: matches } = await supabase.rpc("find_similar_material", {
     p_org_id: quote.organization_id,
     p_search_name: classification.canonical_name,
     p_threshold: 0.3,
   });
   ```
   Note: We pass 0.3 as the search threshold to get a broad set of candidates. The auto-link decision happens at 0.5 (see below).

   b. **If match found** (matches.length > 0 and best match similarity >= 0.5):
   - Use the best match's `id` as `materialId`
   - Add the raw_description as an alias (if not already present):
   ```typescript
   await supabase.from("material_aliases").upsert({
     material_id: materialId,
     alias: lineItem.raw_description,
     normalized_alias: lineItem.raw_description.trim().toLowerCase(),
     source_quote_id: quoteId,
   }, { onConflict: "material_id,normalized_alias" });
   ```
   - Also add the canonical_name as an alias (the AI's normalized form)

   c. **If no match found** (or best match similarity < 0.5):
   - Look up the category_id by matching classification.category to material_categories.name. Default to "other" if not found.
   - Create a new canonical material:
   ```typescript
   const { data: newMaterial } = await supabase.from("materials").insert({
     organization_id: quote.organization_id,
     category_id: categoryId,
     canonical_name: classification.canonical_name,
     species: classification.species,
     dimensions: classification.dimensions,
     grade: classification.grade,
     treatment: classification.treatment,
     unit_of_measure: classification.unit_of_measure,
     aliases: [lineItem.raw_description],
   }).select("id").single();
   ```
   - Handle unique constraint violation on (organization_id, canonical_name) -- if the canonical name already exists (race condition or AI generated same name), re-query and use that material instead.
   - Add raw_description as alias in material_aliases table.

   d. **Update line_item** with the material_id:
   ```typescript
   await supabase.from("line_items")
     .update({ material_id: materialId })
     .eq("id", lineItem.id);
   ```

7. Return success response:
```json
{
  "success": true,
  "quote_id": "...",
  "normalized": 5,
  "new_materials": 2,
  "matched_existing": 3
}
```

**Error handling:**
- Wrap each line item normalization in try/catch so one failure doesn't stop the others
- Log failures but continue processing remaining items
- Return partial success with error details

**Important:** The two-tier threshold design: `find_similar_material` is called with p_threshold=0.3 (broad search), but we only auto-link when the best match has similarity >= 0.5. This prevents false-positive auto-matches while keeping good candidate retrieval.

Deploy the Edge Function:
```bash
cd material-price-intel && npx supabase functions deploy normalize-materials --project-ref xgpjwpwhtfmbvoqtvete
```

If the `supabase` CLI is not available via npx, use the Supabase Management API to deploy. The function files should be at `supabase/functions/normalize-materials/index.ts`.
  </action>
  <verify>
1. Verify the function deployed: `npx supabase functions list --project-ref xgpjwpwhtfmbvoqtvete` should show `normalize-materials`.
2. Test with curl (use a known approved quote_id if available, otherwise verify the function responds to a test call):
```bash
curl -X POST https://xgpjwpwhtfmbvoqtvete.supabase.co/functions/v1/normalize-materials \
  -H "Authorization: Bearer <service_role_key>" \
  -H "Content-Type: application/json" \
  -d '{"quote_id": "nonexistent-id"}'
```
Should return 400 (quote not found), not 500 (function crash).
  </verify>
  <done>
normalize-materials Edge Function deployed. Accepts quote_id, classifies all unnormalized line items via AI, fuzzy-matches against existing materials (search at 0.3, auto-link at 0.5), creates new materials when no match found, sets material_id on all line items, records aliases. Handles errors per-item without failing the batch.
  </done>
</task>

</tasks>

<verification>
- Edge Function `normalize-materials` is deployed and responds to HTTP requests
- classifier.ts contains lumber dimension normalization rules (decimal to nominal)
- Function handles both "match existing" and "create new" paths
- raw_description recorded as alias for every normalized material
- material_id updated on line_items after normalization
- Error in one line item doesn't fail the entire quote normalization
- Two-tier threshold: search at 0.3, auto-link at 0.5
</verification>

<success_criteria>
When a quote is approved, the normalize-materials Edge Function is triggered (by the database trigger from Plan 01). It classifies each line item's raw_description into structured fields, finds or creates a canonical material, links the line item via material_id, and records the description as an alias. Two descriptions for the same material (e.g., "Ipe 5/4x6x16 S4S" and "Ipe decking 1.25x6x16") resolve to the same canonical material.
</success_criteria>

<output>
After completion, create `.planning/phases/05-material-normalization/05-02-SUMMARY.md`
</output>
