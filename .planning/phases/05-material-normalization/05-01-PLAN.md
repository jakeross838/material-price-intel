---
phase: 05-material-normalization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/supabase/migrations/009_material_aliases.sql
  - material-price-intel/src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "material_aliases table exists and can store description-to-material mappings"
    - "find_similar_material searches both canonical_name and aliases for matches"
    - "Normalization results are tracked with source quote context"
  artifacts:
    - path: "material-price-intel/supabase/migrations/009_material_aliases.sql"
      provides: "material_aliases table, updated find_similar_material, normalize trigger on approve"
      contains: "CREATE TABLE material_aliases"
    - path: "material-price-intel/src/lib/types.ts"
      provides: "MaterialAlias type and normalize_materials RPC type"
      contains: "MaterialAlias"
  key_links:
    - from: "material_aliases"
      to: "materials"
      via: "material_id FK"
      pattern: "REFERENCES materials"
    - from: "material_aliases"
      to: "line_items"
      via: "raw_description matching"
      pattern: "raw_description TEXT NOT NULL"
---

<objective>
Create the database schema for material normalization: a `material_aliases` table that tracks every description variation mapped to a canonical material, an enhanced `find_similar_material()` function that searches both canonical names AND aliases, and a database trigger on `approve_quote` that fires the normalization Edge Function via pg_net.

Purpose: The alias table is the foundation that makes cross-supplier price comparison work. Without it, "Ipe 5/4x6x16 S4S" and "Ipe decking 1.25x6x16" remain disconnected line items. The trigger ensures normalization happens automatically when quotes are approved.

Output: SQL migration deployed to remote database, TypeScript types updated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/supabase/migrations/002_schema.sql
@material-price-intel/supabase/migrations/005_functions.sql
@material-price-intel/supabase/migrations/003_indexes.sql
@material-price-intel/supabase/migrations/007_extraction_trigger.sql
@material-price-intel/supabase/migrations/008_approved_status_and_rpc.sql
@material-price-intel/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create material_aliases table and enhanced functions</name>
  <files>material-price-intel/supabase/migrations/009_material_aliases.sql</files>
  <action>
Create migration `009_material_aliases.sql` with:

**1. material_aliases table:**
```sql
CREATE TABLE material_aliases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  material_id UUID NOT NULL REFERENCES materials(id) ON DELETE CASCADE,
  alias TEXT NOT NULL,                    -- The raw description variation
  normalized_alias TEXT NOT NULL,         -- Lowercase trimmed for matching
  source_quote_id UUID REFERENCES quotes(id),  -- Which quote introduced this alias
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (material_id, normalized_alias)  -- Same alias can't map to same material twice
);
```

**2. Indexes on material_aliases:**
```sql
CREATE INDEX idx_material_aliases_material_id ON material_aliases(material_id);
CREATE INDEX idx_material_aliases_normalized_trgm ON material_aliases USING gin (normalized_alias gin_trgm_ops);
```

**3. Enhanced find_similar_material function:**
Replace the existing `find_similar_material()` function. The new version searches BOTH `materials.canonical_name` AND `material_aliases.normalized_alias`, returning the best match from either source. Use `CREATE OR REPLACE FUNCTION` since it already exists.

```sql
CREATE OR REPLACE FUNCTION find_similar_material(
  p_org_id UUID,
  p_search_name TEXT,
  p_threshold REAL DEFAULT 0.3
)
RETURNS TABLE(id UUID, canonical_name TEXT, similarity REAL) AS $$
BEGIN
  RETURN QUERY
  WITH canonical_matches AS (
    SELECT m.id, m.canonical_name,
           similarity(m.canonical_name, p_search_name) AS sim
    FROM materials m
    WHERE m.organization_id = p_org_id
      AND m.is_active = TRUE
      AND similarity(m.canonical_name, p_search_name) > p_threshold
  ),
  alias_matches AS (
    SELECT m.id, m.canonical_name,
           similarity(ma.normalized_alias, p_search_name) AS sim
    FROM material_aliases ma
    JOIN materials m ON ma.material_id = m.id
    WHERE m.organization_id = p_org_id
      AND m.is_active = TRUE
      AND similarity(ma.normalized_alias, p_search_name) > p_threshold
  ),
  all_matches AS (
    SELECT * FROM canonical_matches
    UNION ALL
    SELECT * FROM alias_matches
  )
  SELECT DISTINCT ON (am.id) am.id, am.canonical_name, am.sim AS similarity
  FROM all_matches am
  ORDER BY am.id, am.sim DESC
  LIMIT 5;
END;
$$ LANGUAGE plpgsql STABLE;
```

Note: The DISTINCT ON ensures each material appears once with its highest similarity score from either canonical name or alias.

**4. Merge materials helper function:**
```sql
CREATE OR REPLACE FUNCTION merge_materials(
  p_keep_id UUID,
  p_merge_id UUID
)
RETURNS VOID AS $$
BEGIN
  -- Verify caller owns both materials
  IF NOT EXISTS (
    SELECT 1 FROM materials WHERE id = p_keep_id AND organization_id = public.user_org_id()
  ) THEN
    RAISE EXCEPTION 'Keep material not found or access denied';
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM materials WHERE id = p_merge_id AND organization_id = public.user_org_id()
  ) THEN
    RAISE EXCEPTION 'Merge material not found or access denied';
  END IF;

  -- Move all line_items from merge material to keep material
  UPDATE line_items SET material_id = p_keep_id WHERE material_id = p_merge_id;

  -- Move aliases from merge material to keep material (skip duplicates)
  INSERT INTO material_aliases (material_id, alias, normalized_alias, source_quote_id)
  SELECT p_keep_id, alias, normalized_alias, source_quote_id
  FROM material_aliases WHERE material_id = p_merge_id
  ON CONFLICT (material_id, normalized_alias) DO NOTHING;

  -- Add the merged material's canonical_name as an alias on the kept material
  INSERT INTO material_aliases (material_id, alias, normalized_alias)
  VALUES (p_keep_id, (SELECT canonical_name FROM materials WHERE id = p_merge_id),
          LOWER(TRIM((SELECT canonical_name FROM materials WHERE id = p_merge_id))))
  ON CONFLICT (material_id, normalized_alias) DO NOTHING;

  -- Delete aliases that pointed to merged material
  DELETE FROM material_aliases WHERE material_id = p_merge_id;

  -- Deactivate the merged material (soft delete to preserve history)
  UPDATE materials SET is_active = FALSE WHERE id = p_merge_id;
END;
$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;
```

**5. Database trigger to fire normalization on quote approval:**
Follow the same pattern as `007_extraction_trigger.sql` using pg_net. When `quotes.is_verified` changes from FALSE to TRUE, call the `normalize-materials` Edge Function via pg_net.

```sql
CREATE OR REPLACE FUNCTION trigger_normalize_materials()
RETURNS TRIGGER AS $$
DECLARE
  edge_function_url TEXT;
  service_role_key TEXT;
BEGIN
  -- Only fire when is_verified changes to TRUE
  IF NEW.is_verified = TRUE AND (OLD.is_verified IS DISTINCT FROM TRUE) THEN
    edge_function_url := current_setting('app.settings.supabase_url', true)
      || '/functions/v1/normalize-materials';

    -- Fallback to hardcoded URL if setting not available
    IF edge_function_url IS NULL OR edge_function_url = '' THEN
      edge_function_url := 'https://xgpjwpwhtfmbvoqtvete.supabase.co/functions/v1/normalize-materials';
    END IF;

    service_role_key := current_setting('app.settings.service_role_key', true);

    PERFORM net.http_post(
      url := edge_function_url,
      body := jsonb_build_object('quote_id', NEW.id),
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || service_role_key
      )
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_quote_approved_normalize
  AFTER UPDATE ON quotes
  FOR EACH ROW
  WHEN (NEW.is_verified = TRUE AND OLD.is_verified IS DISTINCT FROM TRUE)
  EXECUTE FUNCTION trigger_normalize_materials();
```

Deploy the migration using:
```
node "C:/Users/Greg/AppData/Local/Temp/claude/P--Claude-Projects-Live-price-database/ba705ce0-54fe-4174-964e-c74259dde385/scratchpad/run-sql.mjs" sbp_38e7d5c8cbd10d895e2742ceaa418f8cc465f59d "material-price-intel/supabase/migrations/009_material_aliases.sql"
```

If the run-sql.mjs script is not found at that path, create a temporary SQL runner script that uses the Supabase Management API to execute SQL. The project ref is `xgpjwpwhtfmbvoqtvete` and the access token is `sbp_38e7d5c8cbd10d895e2742ceaa418f8cc465f59d`. Use the endpoint: `POST https://api.supabase.com/v1/projects/{ref}/database/query` with body `{ "query": "<SQL>" }` and header `Authorization: Bearer <token>`.
  </action>
  <verify>
Run a test query against the database to verify the migration applied:
```sql
SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'material_aliases' ORDER BY ordinal_position;
```
Also verify the trigger exists:
```sql
SELECT trigger_name FROM information_schema.triggers WHERE event_object_table = 'quotes' AND trigger_name = 'on_quote_approved_normalize';
```
And verify the function exists:
```sql
SELECT proname FROM pg_proc WHERE proname = 'merge_materials';
```
  </verify>
  <done>
material_aliases table created with material_id FK, alias, normalized_alias, source_quote_id. GIN trigram index on normalized_alias. find_similar_material() searches both canonical names and aliases. merge_materials() function moves line items and aliases. Database trigger fires normalize-materials Edge Function when quote is approved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types for material aliases and normalization RPC</name>
  <files>material-price-intel/src/lib/types.ts</files>
  <action>
Add the following to `types.ts`:

1. Add `MaterialAlias` type after the `Material` type:
```typescript
export type MaterialAlias = {
  id: string;
  material_id: string;
  alias: string;
  normalized_alias: string;
  source_quote_id: string | null;
  created_at: string;
};
```

2. Add `material_aliases` to the Database Tables section:
```typescript
material_aliases: {
  Row: MaterialAlias;
  Insert: Omit<MaterialAlias, "id" | "created_at">;
  Update: Partial<Omit<MaterialAlias, "id" | "created_at">>;
  Relationships: [];
};
```

3. Add RPC function types to the Database Functions section:
```typescript
merge_materials: {
  Args: { p_keep_id: string; p_merge_id: string };
  Returns: undefined;
};
find_similar_material: {
  Args: { p_org_id: string; p_search_name: string; p_threshold?: number };
  Returns: Array<{ id: string; canonical_name: string; similarity: number }>;
};
```
  </action>
  <verify>Run `cd material-price-intel && npx tsc --noEmit` to verify no type errors.</verify>
  <done>MaterialAlias type defined. material_aliases table in Database type. merge_materials and find_similar_material RPC types declared. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
- material_aliases table exists in remote database with correct columns
- GIN trigram index on normalized_alias confirmed
- find_similar_material() function updated (check function source shows alias_matches CTE)
- merge_materials() function exists
- on_quote_approved_normalize trigger exists on quotes table
- TypeScript compiles with new types
</verification>

<success_criteria>
Database schema supports material normalization: aliases tracked per material, fuzzy search includes aliases, materials can be merged, and quote approval triggers normalization automatically.
</success_criteria>

<output>
After completion, create `.planning/phases/05-material-normalization/05-01-SUMMARY.md`
</output>
