---
phase: 08-reports-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - material-price-intel/package.json
  - material-price-intel/src/hooks/useReportsData.ts
  - material-price-intel/src/pages/ReportsPage.tsx
  - material-price-intel/src/App.tsx
  - material-price-intel/src/components/layout/AppLayout.tsx
autonomous: true

must_haves:
  truths:
    - "Reports page loads and displays data from verified quotes"
    - "Reports page is accessible via /reports route and sidebar navigation"
    - "Filter selections correctly narrow the displayed data set"
    - "Summary stat cards show average price, trend direction, best supplier, and quote count"
  artifacts:
    - path: "material-price-intel/src/hooks/useReportsData.ts"
      provides: "Data fetching hook for reports with joined line_item/quote/supplier/material data"
      exports: ["useReportsData", "useMaterialCategories", "useSuppliers"]
    - path: "material-price-intel/src/pages/ReportsPage.tsx"
      provides: "Reports page with filter panel and summary stat cards"
      exports: ["ReportsPage"]
    - path: "material-price-intel/src/App.tsx"
      provides: "Route entry for /reports"
      contains: "reports"
    - path: "material-price-intel/src/components/layout/AppLayout.tsx"
      provides: "Sidebar nav item for Reports"
      contains: "Reports"
  key_links:
    - from: "material-price-intel/src/pages/ReportsPage.tsx"
      to: "material-price-intel/src/hooks/useReportsData.ts"
      via: "import and call useReportsData()"
      pattern: "useReportsData"
    - from: "material-price-intel/src/App.tsx"
      to: "material-price-intel/src/pages/ReportsPage.tsx"
      via: "Route element"
      pattern: "ReportsPage"
---

<objective>
Install Recharts, create the data-fetching hooks for reports, build the ReportsPage skeleton with filter panel and summary stat cards, and wire up routing and navigation.

Purpose: Establishes all foundation for the analytics dashboard -- chart library available, data flowing, filters working, stats visible. Plans 02 and 03 add chart components into this page.
Output: A functional /reports page with working filters and stat cards but no charts yet (charts come in Plans 02 and 03).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@material-price-intel/src/pages/SearchPage.tsx
@material-price-intel/src/pages/DashboardPage.tsx
@material-price-intel/src/hooks/useMaterials.ts
@material-price-intel/src/lib/types.ts
@material-price-intel/src/lib/supabase.ts
@material-price-intel/src/App.tsx
@material-price-intel/src/components/layout/AppLayout.tsx
@material-price-intel/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Recharts and create data-fetching hook</name>
  <files>
    material-price-intel/package.json
    material-price-intel/src/hooks/useReportsData.ts
  </files>
  <action>
    **Step 1: Install Recharts**

    Run `npm install recharts` inside the `material-price-intel/` directory. Recharts is a lightweight, composable React charting library built on D3. It works natively with React 19 and has zero config -- just import components. Do NOT install @types/recharts (Recharts ships its own types).

    **Step 2: Create `src/hooks/useReportsData.ts`**

    Create a dedicated data hook file for the reports page. Follow the same patterns as `useMaterials.ts` -- named exports, React Query with 5-min staleTime, supabase client from `@/lib/supabase`.

    The hook `useReportsData()` should:
    1. Query `line_items` table with joins to `quotes`, `suppliers`, and `materials` (via material_id FK)
    2. Only include line items that have a `material_id` (not null) AND a `unit_price` (not null) -- unlinked items have no analytical value
    3. Select these fields:
       - From line_items: `id, raw_description, quantity, unit, unit_price, line_total, material_id`
       - From quotes (via join): `id, quote_date, quote_number, project_name, supplier_id, is_verified`
       - From suppliers (via quotes join): `id, name`
       - From materials (via material_id): `id, canonical_name, category_id`
    4. Do NOT attempt to filter `is_verified` in the Supabase PostgREST query. PostgREST cannot reliably filter on joined table columns. Instead, fetch all joined data and filter client-side during the flattening step (step 5 below).
    5. Flatten the joined response into a typed array. During the flattening/map step, **exclude any items where the joined quote's `is_verified` is not `true`**. This is the same pattern SearchPage uses -- fetch all, filter in JS. Define the type inline in the hook file:

    ```typescript
    export type ReportDataPoint = {
      lineItemId: string;
      rawDescription: string;
      quantity: number | null;
      unit: string | null;
      unitPrice: number;        // guaranteed non-null by filter
      lineTotal: number | null;
      quoteId: string;
      quoteDate: string | null;
      quoteNumber: string | null;
      projectName: string | null;
      supplierId: string;
      supplierName: string;
      materialId: string;       // guaranteed non-null by filter
      canonicalName: string;    // guaranteed non-null by filter
      categoryId: string | null;
    };
    ```

    In the flattening step, the code should look like:
    ```typescript
    const flattened = (data ?? [])
      .filter(item => item.quotes?.is_verified === true)
      .map(item => ({
        // ... map fields
      }));
    ```

    6. Order by quote_date ascending (chronological for charting)

    Also export `useReportsCategories()` and `useReportsSuppliers()` hooks -- these can be identical to the ones in SearchPage.tsx (query `material_categories` ordered by sort_order, and `suppliers` ordered by name). Extracting them into this shared hook file avoids duplication. Use the same query keys: `["material_categories"]` and `["suppliers_list"]` so React Query deduplicates if both pages are mounted.

    Also export `useReportsMaterials()` -- a lightweight hook that queries the `materials` table for just `id, canonical_name, category_id` where `is_active = true`, ordered by `canonical_name`. This populates the material filter dropdown. Query key: `["materials_for_filter"]`.
  </action>
  <verify>
    1. Run `cd material-price-intel && npx tsc --noEmit` -- no TypeScript errors
    2. Run `cd material-price-intel && npm run build` -- build succeeds
    3. Verify `recharts` appears in package.json dependencies
    4. Verify `useReportsData.ts` exports: `useReportsData`, `useReportsCategories`, `useReportsSuppliers`, `useReportsMaterials`, `ReportDataPoint`
    5. Grep for `is_verified === true` in useReportsData.ts -- client-side filter present
    6. Confirm there is NO `.eq("is_verified", true)` or similar server-side filter on the joined quotes column
  </verify>
  <done>
    Recharts installed. Data hook file exists with typed exports. Verified quotes are filtered client-side during flattening (not via PostgREST on joined columns). TypeScript compiles cleanly. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ReportsPage with filters and stat cards, wire route and nav</name>
  <files>
    material-price-intel/src/pages/ReportsPage.tsx
    material-price-intel/src/App.tsx
    material-price-intel/src/components/layout/AppLayout.tsx
  </files>
  <action>
    **Step 1: Create `src/pages/ReportsPage.tsx`**

    Follow the existing page pattern: `export function ReportsPage()`. Use the same component imports as SearchPage/DashboardPage (Card, CardContent, CardHeader, CardTitle, Button, Input, Label from shadcn; Lucide icons; supabase from @/lib/supabase).

    The page structure:

    **Header:**
    ```
    <h2 class="text-3xl font-bold tracking-tight">Reports</h2>
    <p class="text-muted-foreground mt-2">Price trends and supplier comparison analytics</p>
    ```

    **Filter Panel (always visible, no toggle):**
    A Card containing a grid (grid-cols-1 md:grid-cols-5 gap-4) with these filters:
    1. **Material Category** -- `<select>` dropdown populated from `useReportsCategories()`. Options: "All Categories" (value="all") + each category. When changed, reset material filter to "all".
    2. **Specific Material** -- `<select>` dropdown populated from `useReportsMaterials()`, filtered by selected category. Options: "All Materials" (value="all") + each material.
    3. **Supplier** -- `<select>` dropdown from `useReportsSuppliers()`. Options: "All Suppliers" (value="all") + each supplier.
    4. **Date From** -- `<input type="date">` for start date range.
    5. **Date To** -- `<input type="date">` for end date range.

    Use the same select styling as SearchPage: `className="h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-xs"`

    Add a "Clear Filters" button (variant="ghost", with X icon from lucide) that appears when any filter is active.

    **Filter state -- IMPORTANT: Follow SearchPage pattern exactly.**
    Use `useState` for each filter. Default values must be `"all"` (not empty string `""`). This matches SearchPage:
    ```typescript
    const [categoryFilter, setCategoryFilter] = useState<string>("all");
    const [materialFilter, setMaterialFilter] = useState<string>("all");
    const [supplierFilter, setSupplierFilter] = useState<string>("all");
    const [dateFrom, setDateFrom] = useState<string>("");
    const [dateTo, setDateTo] = useState<string>("");
    ```

    Create a `useMemo` that filters the `useReportsData()` results based on all active filters. Use `!== "all"` checks (NOT empty string checks):
    ```typescript
    const filteredData = useMemo(() => {
      return reportData.filter(item => {
        if (categoryFilter !== "all" && item.categoryId !== categoryFilter) return false;
        if (materialFilter !== "all" && item.materialId !== materialFilter) return false;
        if (supplierFilter !== "all" && item.supplierName !== supplierFilter) return false;
        if (dateFrom && item.quoteDate && item.quoteDate < dateFrom) return false;
        if (dateTo && item.quoteDate && item.quoteDate > dateTo) return false;
        return true;
      });
    }, [reportData, categoryFilter, materialFilter, supplierFilter, dateFrom, dateTo]);
    ```

    The `hasFilters` check should be:
    ```typescript
    const hasFilters = categoryFilter !== "all" || materialFilter !== "all" || supplierFilter !== "all" || dateFrom || dateTo;
    ```

    The clear function resets to "all":
    ```typescript
    const clearFilters = () => {
      setCategoryFilter("all");
      setMaterialFilter("all");
      setSupplierFilter("all");
      setDateFrom("");
      setDateTo("");
    };
    ```

    **Summary Stat Cards:**
    A grid (grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4) below the filters with 4 cards computed from filtered data:

    1. **Average Price** -- Mean of all unitPrice values in filtered set. Display with `$X.XX` format. Use Lucide `DollarSign` icon with blue-100 bg / blue-600 text.

    2. **Price Trend** -- Compare average price of most recent 50% of data points (by date) vs oldest 50%. If recent > old by >5%, show TrendingUp (red icon, "Rising"). If recent < old by >5%, show TrendingDown (green icon, "Falling"). Otherwise show Minus (slate icon, "Stable"). Display the percentage change.

    3. **Best Supplier** -- Supplier with the lowest average unit price across filtered set. Display supplier name. Use Lucide `Award` icon with green-100 bg / green-600 text. If no data, show "--".

    4. **Quote Count** -- Count of unique quoteId values in filtered set. Use Lucide `FileText` icon with slate-100 bg / slate-600 text.

    Use the same stat card pattern as SearchPage (Card > CardContent with flex items-center gap-3, icon in colored rounded-lg div, text beside it).

    **Chart placeholder:**
    Below the stat cards, add a single Card with CardHeader "Price Trends" and CardContent containing a centered muted-foreground paragraph: "Chart loading..." (Plan 02 will replace this with the actual Recharts chart). Give this card an id or a clear comment like `{/* CHART PLACEHOLDER - replaced in Plan 02 */}`.

    **Loading state:**
    While `useReportsData()` is loading, show a centered Loader2 spinner with "Loading analytics data..." text, same pattern as SearchPage.

    **Empty state:**
    If filtered data has 0 results, show an empty state Card with BarChart3 icon and message "No price data matches your filters. Try broadening your selection." or if no filters are active: "No verified price data yet. Upload and approve quotes to see analytics."

    **Step 2: Add route to App.tsx**

    Import `ReportsPage` from `@/pages/ReportsPage` and add a Route:
    ```tsx
    <Route path="/reports" element={<ReportsPage />} />
    ```
    Place it after the `/search` route, still inside the ProtectedRoute > AppLayout nesting.

    **Step 3: Add nav item to AppLayout.tsx**

    Import `BarChart3` from `lucide-react` and add to the navItems array:
    ```typescript
    { to: "/reports", label: "Reports", icon: BarChart3 },
    ```
    Place it after the Search entry (last item before the sidebar footer).
  </action>
  <verify>
    1. Run `cd material-price-intel && npx tsc --noEmit` -- no TypeScript errors
    2. Run `cd material-price-intel && npm run build` -- build succeeds
    3. Verify ReportsPage.tsx exports `ReportsPage`
    4. Verify App.tsx has `/reports` route
    5. Verify AppLayout.tsx navItems includes "Reports" with BarChart3 icon
    6. Grep ReportsPage.tsx for: useReportsData, useReportsCategories, useReportsSuppliers, useReportsMaterials (all 4 hooks used)
    7. Grep ReportsPage.tsx for: "Average", "Trend", "Best Supplier", "Quote Count" (all 4 stat cards present)
    8. Grep ReportsPage.tsx for `"all"` -- confirm filter defaults use "all" not empty string
    9. Grep ReportsPage.tsx for `!== "all"` -- confirm filter logic uses "all" comparison pattern
  </verify>
  <done>
    ReportsPage renders with working filter panel (5 filters: category, material, supplier, date from, date to) using "all" as default values matching SearchPage pattern. 4 summary stat cards computed from filtered data. Route /reports is accessible. Sidebar shows "Reports" link with BarChart3 icon. Chart area is placeholder -- ready for Plan 02. Build passes cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` in material-price-intel/ passes with zero errors
2. The /reports route exists in App.tsx
3. The sidebar navigation includes a "Reports" link
4. ReportsPage.tsx uses all four data hooks
5. Filter panel has 5 filter controls (category, material, supplier, date-from, date-to)
6. 4 stat cards render with computed values from filtered data
7. Recharts is in package.json dependencies
8. Filter defaults are "all" and filter logic uses `!== "all"` checks (matching SearchPage)
9. Verified-quote filtering happens client-side during data flattening, not via PostgREST
</verification>

<success_criteria>
- Recharts installed and available for import
- /reports route accessible and renders ReportsPage
- Sidebar shows Reports link with chart icon
- Filter panel filters data by category, material, supplier, and date range using "all" default pattern
- Stat cards display: average price, price trend (up/down/stable), best supplier name, unique quote count
- Page handles loading, empty, and populated states
- Only verified quotes appear in analytics data (filtered client-side)
- TypeScript compiles cleanly, Vite build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/08-reports-analytics/08-01-SUMMARY.md`
</output>
